#!/bin/sh --
# by pts@fazekas.hu at Mon Dec  7 14:58:29 CET 2020
#
# Tested on host system: Ubuntu 18.04.
#
# TODO(pts): sudo apt-get install -y systemd-container  # For systemd-nspawn.
# TODO(pts): sudo apt-get install -y iproute2  # For ip.
# TODO(pts): systemd-nspawn --notify-ready=
# TODO(pts): stty \.../
# TODO(pts): (apt-get install modprobe?) kmod-static-nodes.service: Main process exited, code=exited, status=203/EXEC
#            [FAILED] Failed to start Create list of requâ€¦vice nodes for the current kernel.
# !! TODO(pts): doc: Debian: this is normal: -- make it optional
#               Failed to mount n/a on /tmp/runc/co18.container/rootfs/sys/fs/selinux (MS_BIND ""): No such file or directory
#               Failed to mount n/a on /tmp/runc/co18.container/rootfs/sys/fs/selinux (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_REMOUNT|MS_BIND ""): Invalid argument
# !! TODO(pts): why needed after: apt-get install docker? systemctl start docker; also for openssh-server; solution: rm /usr/sbin/policy-rc.d
# !! TODO(pts): The --bind /shared directory.
# !! TODO(pts): timezone -- which packages are needed?
# !! TODO(pts): /etc/default/locale ?
# !! TODO(pts): Add "$HOSTNETIP host" to /etc/hosts , also copy from/to host /etc/hosts
# !! TODO(pts): Add other type of networking: same-as-host (bind on the same port won't work), private, separate-ip (currently implemented), to-host, to-host-and-containers, host (-n, may include masquerade; only works if the container is also running systemd (because of DHCP client); no communication with other containers).
#
# Host compatibility:
#
# * Ubuntu 14.04: Doesn't work, it doesn't have systemd-nspawn.
# * Ubuntu 16.04: ??
# * Ubuntu 18.04: Tested, it works. It has systemd 237.
# * Ubuntu 20.04: Tested, it works.
# * Debian 9: It has systemd 232, whose systemd-nspawn doesn't have --system-call-filter=..., so it doesn't support Docker.
# * Debian 10: It works.
#

if test -z "$RUNN_RERUN" && ! (test $# = 0 || test "$1" = --help); then
  unset S
  test "$(id -u)" != 0 && S='sudo --'
  exec $S /usr/bin/env -i TZ="$TZ" TERM="$TERM" RUNN_RERUN=1 /bin/sh "$0" "$@"
  exit 1
fi

CMD=
if test "$1" = start || test "$1" = shell || test "$1" = poweroff || test "$1" = kill || test "$1" = show; then
  if test $# != 1; then
    CMD="$1"; CONAME="$2"; shift; shift
  fi
elif test "$1" = list; then
  if test $# = 1; then
    CMD="$1"; shift
  fi
elif test $# = 1 && test "${1#-}" = "$1"; then
  CMD=start; CONAME="$1"; shift
fi
if test "$CMD" = start || test "$CMD" = poweroff || test "$CMD" = show; then
  test $# != 0 && CMD=  # Too many command-line arguments.
fi
if ! test "$CMD"; then
  echo "\
Usage: $0 [start] <container-name>
       $0 shell <container-name>
       $0 show <container-name>
       $0 poweroff <container-name>  # Gracefully, don't wait.
       $0 kill <container-name> [<arg> ...]
       $0 list  # List active containers." >&2
  exit 1
fi

if test "$CMD" = list; then
  exec machinectl "$CMD" "$@"
  echo "fatal: command not found: machinectl" >&2
  exit 2
fi

case "$CONAME" in
 -* | *[!-._a-zA-Z0-9]* | "") echo "fatal: bad container name: $CONAME"; exit 1 ;;
esac
CODIR="${0%/*}"
cd "$CODIR" || exit 2

if test "$CMD" = start || test "$CMD" = shell; then
  if machinectl show "$CONAME" 2>/dev/null >&2; then  # Early exit.
    if test "$CMD" = start; then
      echo "info: shutdown gracefully: $0 poweroff $CONAME" >&2
      echo "info: force kill: $0 kill $CONAME -s 9" >&2
      echo "fatal: container already running: $CONAME" >&2
      exit 2
    fi
  elif test "$CMD" = shell; then
    CMD=start-shell
    if test $# != 0 && test "${1#/}" = "$1"; then
      # For compatibility with machinectl shell.
      echo "fatal: shell command must start with /: $1" >&2
      exit 1
    fi
  fi
fi
if test "$CMD" = shell && test $# = 0; then  # machinectl systemd 232 doesn't autodetect /bin/bash.
  test -f "$CONAME".container/rootfs/bin/bash && set /bin/bash -l
fi
if test "$CMD" != start && test "$CMD" != start-shell; then
  exec machinectl "$CMD" "$CONAME" "$@"
  echo "fatal: command not found: machinectl" >&2
  exit 2
fi

if ! test -f "busybox.conconj" || ! test -x "busybox.conconj"; then
  echo "fatal: executable not found: $CODIR/busybox.conconj"
  exit 2
fi

if ! test -d "$CONAME.container/rootfs"; then
  echo "fatal: missing rootfs directory in container: $CODIR/$CONAME.container/rootfs"
  exit 2
fi

if ! test -f "$CONAME.container/rootfs/bin/sh"; then
  echo "fatal: missing shell in container: $CODIR/$CONAME.container/rootfs/bin/sh"
  exit 2
fi

if ! perl -e0 2>/dev/null; then
  echo "fatal: perl doesn't work" >&2
  exit 2
fi

if ! read HOSTNETIP <conconj.hostnet 2>/dev/null; then
  echo "fatal: missing or empty: $CODIR/conconj.hostnet"
  exit 2
fi

# ---

chown 0.0 "$CONAME".container/rootfs || exit 2

# Example: HOSTNETIP=192.168.0.90 NETDEV=wlp2s0
NETDEV="$(ip -o addr | perl -we 'use integer; use strict;
    die "fatal: bad hostnetip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@;
    my $hostnetip = unpack("N", pack("C4", $1, $2, $3, $4));
    my $netdev; my $netmaskbits; my $netmask;
    while (<STDIN>) { chomp; my @l = split; if (@l > 3 and $l[2] eq "inet" and $l[1] ne "lo" and $l[3] =~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)/(\d+)\Z(?!\n)@ and $5 != 32 and $5 >= 8 and $5 <= 32) {
      my $ip = unpack("N", pack("C4", $1, $2, $3, $4)); my $mask = unpack("N", pack("N", -1 << (32 - $5))); if (($ip & $mask) == ($hostnetip & $mask)) {
        die "fatal: multiple network devices for hostnetip: $ARGV[0]\n" if defined($netdev);  # The $5 != 32 check above ensures that hostnet is ignored here.
        $netdev = $l[1]; $netmaskbits = $5; $netmask = $mask; } } }
    die "fatal: missing network device for hostnetip: $ARGV[0]\n" if !defined($netdev);
    $netmask = join(".", unpack("C4", pack("N", $netmask)));
    print "NETDEV=\x27$netdev\x27; NETMASKBITS=\x27$netmaskbits\x27; NETMASK=\x27$netmask\x27\n"' -- "$HOSTNETIP")"
test "$NETDEV" || exit 2
eval "$NETDEV"  # Set NETDEV=...; NETMASKBITS=...; NETMASK=...
test "$NETDEV" || exit 2
test "$NETMASKBITS" || exit 2

NETGATEWAY="$(ip route | while read A B C D; do test "$A" = default && test "$B" = via && echo "$C" && break; done)"
if test -z "$NETGATEWAY"; then
  echo "fatal: missing default gateway" >&2
  exit 2
fi

UR=
read UR </proc/sys/kernel/osrelease  # It's OK to fail.
if test "$UR" && test -d /lib/modules/"$UR"; then
  BM="--bind-ro /lib/modules/$UR"
else
  # TODO(pts): Disallow whitespace in $UR.
  BM=
fi

ISSR=
while read A B C; do
  test "$A" = nameserver && test "$B" = 127.0.0.53 && ISSR=1 && break  # systemd-resolved.
done </etc/resolv.conf
if test "$ISSR"; then
  # systemd-resolve: systemd 237, Ubuntu 18.04
  # resolvectl: systemd 245.4, Ubuntu 20.04
  LINE="$(systemd-resolve --status "$NETDEV" 2>/dev/null || resolvectl --status "$NETDEV" 2>/dev/null)"  # Network interface.
  case "$LINE" in
   *DNS\ Servers:\ *) ISSR=2 ;;
  esac
else
  LINE="$(cat /etc/resolv.conf)"
fi
# Now "$LINE" contains the DNS configuration of the host.
# TODO(pts): Add a config option to keep it unmodified.

# Example: ../run/systemd/resolve/stub-resolv.conf
RCL="$(readlink "$CONAME".container/rootfs/etc/resolv.conf)"
if test "$RCL"; then
  A=; case "$RCL" in ../*) A="${RCL#*/}" ;; esac
  test "$A" && case "$A/" in */../*) A="" ;; esac  # Safety.
  case "$A" in run/systemd/resolve/*) test -d "$CONAME".container/rootfs/run/systemd/resolve || mkdir -p "$CONAME".container/rootfs/run/systemd/resolve || exit 2; RCL= ;; esac
fi


if ! test "$RCL"; then  # Container /etc/resolv.conf is not a symlink or it is a systemd symlink.
  : >>"$CONAME".container/rootfs/etc/resolv.conf.container  # Create it if needed.
  # Copy over host resolve config to container /etc/resolv.conf.
  echo "$LINE" | perl -ni -0777 -we '
      use integer; use strict; our %conf; our %confhad;
      BEGIN {
        $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = "";
        local $/ = "\n";
        while (<STDIN>) {
          s@^\s+@@;
          if (s@(.*?): @@) { $key = $1 } elsif (s@^nameserver\s+@@) { $key = "DNS Servers" }
          chomp; next if !length or m@^#@;
          if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ }
        }
        $conf{LLMNR} = "no";
      }
      my $infile = $_;
      while ($infile =~ m@\G(\n|.+\n?)@gc) {
        $_ = $1;
        $_ .= "\n" if !m@\n@; if (m@^nameserver\s+@ and exists($conf{DNS})) { if (!exists($confhad{DNS})) { for my $dns (split(/ /, $conf{DNS})) { print "nameserver $dns\n" } $confhad{DNS} = 1 } } else { print }
      }
      if (exists($conf{DNS}) and !exists($confhad{DNS})) { for my $dns (split(/ /, $conf{DNS})) { print "nameserver $dns\n" } }
  ' "$CONAME".container/rootfs/etc/resolv.conf.container || exit 2
fi

# TODO(pts): Security: don't follow symlinks.
#
# The file "$CONAME".container/rootfs/etc/systemd/resolved.conf is user-editable.
if test -f "$CONAME".container/rootfs/etc/systemd/resolved.conf; then
  # Copy over host resolve config to container /etc/systemd/resolved.conf.
  echo "$LINE" | perl -ni -0777 -we '
      use integer; use strict; our %conf; our %confhad;
      BEGIN {
        $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = "";
        local $/ = "\n";
        while (<STDIN>) {
          s@^\s+@@;
          if (s@(.*?): @@) { $key = $1 } elsif (s@^nameserver\s+@@) { $key = "DNS Servers" }
          chomp; next if !length or m@^#@;
          if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ }
        }
        $conf{LLMNR} = "no";
      }
      my $infile = $_;
      while ($infile =~ m@\G(\n|.+\n?)@gc) {
        $_ = $1;
        $_ .= "\n" if !m@\n@; if (m@^#?([^\s#=]+)=@ and exists($conf{$1})) { print "$1=$conf{$1}\n"; $confhad{$1} = 1 } else { print }
      }
      for (sort(keys(%conf))) { print "$_=$conf{$_}\n" if !exists($confhad{$_}) }
  ' "$CONAME".container/rootfs/etc/systemd/resolved.conf || exit 2
fi

# Undo incorrect setup_resolv_conf() magic in systemd-nspawn, which may
# bind-mount or overwrite /etc/resolv.conf .  !! undo
# This affects the `shell' command, which starts a login shell.
: >>"$CONAME".container/rootfs/etc/profile || exit 2  # Create if needed.
: >>"$CONAME".container/rootfs/etc/resolv.conf.container.start || exit 2  # Create.
perl -pi -0777 -we '
    my $cmd = qq(if test -f /etc/resolv.conf.container.start; then umount /etc/resolv.conf 2>/dev/null; rm -f /etc/resolv.conf; cat </etc/resolv.conf.container >/etc/resolv.conf; rm -f /etc/resolv.conf.container.start; :; fi  #conconj\n) .
              qq(if test -f /etc/netup.container; then (. /etc/netup.container); rm -f /etc/netup.container; fi  #conconj\n);
    1 while s@\A(.*) #conconj\n@@;
    substr($_, 0, 0) = $cmd;
    ' "$CONAME".container/rootfs/etc/profile || exit 2

(ip -o addr show hostnet 2>/dev/null | while read A B C D E; do
  if test "$B" = hostnet && test "$C" = inet && test "$D" != "$HOSTNETIP/32"; then
    echo "fatal: device hostnet already up, with IP address ${D%/*}, should be: $HOSTNETIP" >&2
    exit 2
  fi
done) || exit 2

# Undo incorrect setup_resolv_conf() magic in systemd-nspawn, which may
# bind-mount or overwrite /etc/resolv.conf .
# This affects the `start' command (--boot).
# There is no simpler workaround for systemd-nspawn in systemd 237.
# systemd 245.4 has systemd-nspawn --resolv-conf-mode=... to affect this.
if test -d "$CONAME".container/rootfs/etc/systemd/system; then
  # https://www.linode.com/docs/guides/start-service-at-boot/
  echo '
[Unit]
Description=Network interfaces in container
DefaultDependencies=no
Conflicts=shutdown.target
After=
Before=systemd-networkd.service container-resolv-conf.service network.target shutdown.target
#Wants= Requires= Requisite=qqsystemd-resolved.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh /etc/netup.rm.container

[Install]
WantedBy=multi-user.target
' >"$CONAME".container/rootfs/etc/systemd/system/container-network.service || exit 2
  rm -f "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-network.service || exit 2
  # Directory missing before `apt-get install systemd-sysv`.
  if test -d "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants; then
    # Equivalent of in-container: systemctl enable container-network.service
    ln -s /etc/systemd/system/container-network.service "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-network.service || exit 2
  fi
  # !! --network-interface= implies --private-network, so systemd-nspawn doesn't try to mess with /etc/resolv.conf, so this hack is not needed.
  echo '
[Unit]
Description=Set up /etc/resolv.conf in container
DefaultDependencies=no
Conflicts=shutdown.target
After=systemd-resolved.service systemd-networkd.service container-network.service
Before=network.target nss-lookup.target shutdown.target
#Wants= Requires= Requisite=qqsystemd-resolved.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh /etc/resolv.conf.container.setup

[Install]
WantedBy=multi-user.target
' >"$CONAME".container/rootfs/etc/systemd/system/container-resolv-conf.service || exit 2
  echo '
if test -f /etc/resolv.conf.container.start; then
  umount /etc/resolv.conf 2>/dev/null
  rm -f /etc/resolv.conf
  # /run/systemd/resolve/resolv.conf contains actual upstream nameservers.
  if test -f /lib/systemd/resolv.conf && (systemd-resolve --status || resolvectl --status) >/dev/null 2>&1; then
    cat </lib/systemd/resolv.conf >/etc/resolv.conf
  else
    cat </etc/resolv.conf.container >/etc/resolv.conf
  fi
  rm -f /etc/resolv.conf.container.start
  :
fi
' >"$CONAME".container/rootfs/etc/resolv.conf.container.setup || exit 2
  #chmod 755 "$CONAME".container/rootfs/etc/resolv.conf.crontainer.setup || exit 2
  rm -f "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-resolv-conf.service || exit 2
  # Directory missing before `apt-get install systemd-sysv`.
  if test -d "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants; then
    # Equivalent of in-container: systemctl enable container-resolv-conf.service
    ln -s /etc/systemd/system/container-resolv-conf.service "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-resolv-conf.service || exit 2
  fi
  # systemctl status container-resolv-conf.service
fi

if ! ip link show hostnet >/dev/null 2>&1; then
  # https://unix.stackexchange.com/q/622914
  # `type macvlan' works on Etherenet only (no wifi), `type ipvlan mode l2' works everywhere.
  # ipvlan vs macvlan: https://sreeninet.wordpress.com/2016/05/29/macvlan-and-ipvlan/
  # ip link del hostnet ||:
  ip link add hostnet link "$NETDEV" type ipvlan mode l2 || exit 2
  ip addr add "$HOSTNETIP"/32 brd + dev hostnet || exit 2
  ip link set hostnet up || exit 2  # `ip route add' below needs it.
fi

GUESTNETNS=guest."$CONAME"
GUESTIP=
read GUESTIP <"$CONAME".container/ipaddr 2>/dev/null ||:

ip link del "$GUESTNETNS"in 2>/dev/null ||:
# ip -n "$GUESTNETNS" link del "$GUESTNETNS"in 2>/dev/null ||:
if test "$GUESTIP"; then
  # TODO(pts): If everything is all right, don't make any changes, so that
  # currently running shells would continue working.
  ip link add link "$NETDEV" name "$GUESTNETNS"in type ipvlan mode l2 || exit 2
  test "$(ip route show "$GUESTIP"/32)" && ip route del "$GUESTIP"/32
  ip route add "$GUESTIP"/32 dev hostnet || exit 2
fi

# This file is not used directly, it can be used by manually running `ifup -a'
# after `sudo apt-get install -y ifupdown'.
test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
echo "
auto lo
iface lo inet loopback

auto ${GUESTNETNS}in
iface ${GUESTNETNS}in inet static
  address $GUESTIP
  netmask $NETMASK
  gateway $NETGATEWAY
" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
# Broadcast is enabled by default, no need for `broadcast +'.
echo "
    /etc/busybox.conconj ifconfig '${GUESTNETNS}in' '$GUESTIP' netmask '$NETMASK' up || exit \$?
    /etc/busybox.conconj route add default gw '$NETGATEWAY' || exit \$?
">"$CONAME".container/rootfs/etc/netup.container || exit 2
echo "
    if test -f /etc/netup.container; then
      (. /etc/netup.container); XC=\$?
      rm -f /etc/netup.container
      exit \$XC
    fi
">"$CONAME".container/rootfs/etc/netup.rm.container || exit 2
test -d "$CONAME".container/rootfs/etc/default || mkdir "$CONAME".container/rootfs/etc/default || exit 2
# Disable `ifup -a' call in /lib/systemd/system/networking.service
echo 'CONFIGURE_INTERFACES=no
' >"$CONAME".container/rootfs/etc/default/networking || exit 2;
# Broadcast is enabled by default, no need for `broadcast +'.

# !! Add setting without Docker.
# Docker needs --capability=CAP_SYS_MODULE,CAP_NET_ADMIN .
# --bind=/sys/fs/cgroup is needed by docker.
# --capability=CAP_SYS_MODULE,CAP_NET_ADMIN is needed by Docker, but not by iptables.
# --capability=all is too much, not needed.
# By using --network-interface=... (but not --network-namespace-path=...),
# this is not needed, docker can set it up for itself:
#   echo 1 | ip netns exec "$GUESTNETNS" tee /proc/sys/net/ipv4/ip_forward >/dev/null || exit 2

BOOTARG=
test "$CMD" = start-shell || BOOTARG=--boot
set x $BOOTARG --directory="$CONAME".container/rootfs \
    $BM --network-interface="$GUESTNETNS"in --bind-ro="$(pwd)"/busybox.conconj:/etc/busybox.conconj \
    --capability=CAP_SYS_MODULE,CAP_NET_ADMIN \
    --bind=/sys/fs/cgroup --machine="$CONAME" -- "$@"; shift
# With --private-users=no, container systemd freezes with: ``Failed to allocate manager object, freezing.''.
export SYSTEMD_NSPAWN_USE_CGNS=0  # Needed by Docker.

LINE="$(systemd-nspawn --system-call-filter= --directory=/dev/null 2>&1)"
case "$LINE" in *--system-call-filter=*) ;; *) LINE="" ;; esac
SYSTEMD_NSPAWN=systemd-nspawn
if test "$LINE"; then  # Old systemd-nspawn without --system-call-filter=... .
  if ! test -f patch_nspawn.pl; then
    echo "fatal: script not found: $CODIR/patch_nspawn.pl" >&2
    exit 2
  fi
  LINE="$(type systemd-nspawn 2>&1)"
  case "$LINE" in systemd-nspawn\ is\ /*) LINE="${LINE#* is }" ;; *) LINE="" ;; esac
  if test -z "$LINE"; then
    echo "fatal: command not found: systemd-nspawn" >&2
    exit 2
  fi
  # This can patch systemd-nspawn 232 on Debian 9 on Linux amd64.
  if ! perl patch_nspawn.pl "$LINE" systemd-nspawn.docker; then
    echo "fatal: systemd-nspawn does not support --system-call-filter=... , binary patching didn't work" >&2
    exit 2
  fi
  SYSTEMD_NSPAWN="$CODIR"/systemd-nspawn.docker
  set ./systemd-nspawn.docker "$@"
else
  SYSTEMD_NSPAWN=systemd-nspawn
  set "$SYSTEMD_NSPAWN" --system-call-filter="add_key keyctl" "$@"
fi

if test "$CMD" = start-shell; then
  exec "$@"
  echo "fatal: command not found: $1" >&2
  exit 2
fi

exec 9>"$CONAME".container/console.out.tmp </dev/null
"$@" >&9 2>&9 &  # This generates some shell-specific command-not-found error.
exec 9>&2
while ! read LINE <"$CONAME".container/console.out.tmp; do :; done
E=
case "$LINE" in
 Directory\ tree\ *\ is\ currently\ busy*) E=1 ;;
 Spawning\ *) ;;  # Success (at least so far).
 *:\ not\ found | *:\ command\ not\ found) E=2 ;;
 *) E=0 ;;
esac
if test "$E"; then
  if test "$E" = 1; then  # Already unning.
    echo "info: shutdown gracefully: $0 poweroff $CONAME" >&2
    echo "info: force kill: $0 kill $CONAME -s 9" >&2
    echo "fatal: container already running: $CONAME" >&2
  elif test "$E" = 2; then
    echo "fatal: command not found: $SYSTEMD_NSPAWN" >&2
  else #elif test "$E" = 0; then
    cat "$CONAME".container/console.out.tmp >&2
    rm -f "$CONAME".container/console.out.tmp
  fi
  exit 2
fi
mv "$CONAME".container/console.out.tmp "$CONAME".container/console.out

# Perhaps it's too early (race condition) for poweroff or shell now.
echo "info: started; shutdown gracefully: $0 poweroff $CONAME" >&2
echo "info: force kill: $0 kill $CONAME -s 9" >&2
echo "info: view console: less '$CODIR/$CONAME.container/console.out'" >&2
echo "info: root shell: $0 shell $CONAME" >&2

exit 0
