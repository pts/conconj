#!/bin/sh --
# by pts@fazekas.hu at Mon Dec  7 14:58:29 CET 2020
#
# Tested on host system: Ubuntu 18.04.
#
# TODO(pts): sudo apt-get install -y systemd-container  # For systemd-nspawn.
# TODO(pts): sudo apt-get install -y ip  # For iproute2.
# TODO(pts): systemd-nspawn --notify-ready=
# !! TODO(pts): The --bind /shared directory.
# !! TODO(pts): timezone -- which packages are needed?
# !! TODO(pts): /etc/default/locale ?
# !! TODO(pts): Add "$HOSTNETIP host" to /etc/hosts , also copy from/to host /etc/hosts
# !! TODO(pts): Use DNS resolver on the host? Unfortunately, systemd-resolved is not listening:
#               `nc -v 192.168.0.90 53': nc: connect to 192.168.0.90 port 53 (tcp) failed: Connection refused
#

if test -z "$RUNN_RERUN"; then
  unset S
  test "$(id -u)" != 0 && S='sudo --'
  exec $S /usr/bin/env -i TZ="$TZ" RUNN_RERUN=1 /bin/sh "$0" "$@"
  exit 1
fi

if test $# != 1 || test "$1" = "--help"; then
  echo "Usage: $0 <container-name>" >&2
  exit 1
fi
CODIR="${0%/*}"
cd "$CODIR" || exit 2
LINE=

CONAME="$1"
if ! test -d "$CONAME.container/rootfs"; then
  echo "fatal: missing rootfs directory: $CODIR/$CONAME.container/rootfs"
  exit 2
fi
case "$CONAME" in
 *[^-_a-zA-Z0-9]* | "") echo "fatal: bad container name: $CONAME"; exit 1 ;;
esac

if machinectl show "$CONAME" 2>/dev/null; then  # Early exit.
  echo "fatal: container already running: $CONAME" >&2
  exit 2
fi

if ! perl -e0 2>/dev/null; then
  echo "fatal: perl doesn't work" >&2
  exit 2
fi

if ! read HOSTNETIP <conconj.hostnet 2>/dev/null; then
  echo "fatal: missing or empty: $CODIR/conconj.hostnet"
fi
# Example: HOSTNETIP=192.168.0.90 NETDIEV=wlp2s0
NETDEV="$(ip -o addr | perl -we 'use integer; use strict;
    die "fatal: bad hostnetip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@;
    my $hostnetip = unpack("N", pack("C4", $1, $2, $3, $4));
    my $netdev; my $netmaskbits;
    while (<STDIN>) { chomp; my @l = split; if (@l > 3 and $l[2] eq "inet" and $l[1] ne "lo" and $l[3] =~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)/(\d+)\Z(?!\n)@ and $5 != 32 and $5 >= 8 and $5 <= 32) {
      my $ip = unpack("N", pack("C4", $1, $2, $3, $4)); my $mask = unpack("N", pack("N", -1 << (32 - $5))); if (($ip & $mask) == ($hostnetip & $mask)) {
        die "fatal: multiple network devices for hostnetip: $ARGV[0]\n" if defined($netdev);
        $netdev = $l[1]; $netmaskbits = $5; } } }
    die "fatal: missing network device for hostnetip: $ARGV[0]\n" if !defined($netdev);
    print "$netdev $netmaskbits\n"' -- "$HOSTNETIP")"
NETMASKBITS="${NETDEV#* }"
NETDEV="${NETDEV%% *}"
test "$NETDEV" || exit 2
test "$NETMASKBITS" || exit 2

UR=
read UR </proc/sys/kernel/osrelease  # It's OK to fail.
if test "$UR" && test -d /lib/modules/"$UR"; then
  BM="--bind-ro /lib/modules/$UR"
else
  # TODO(pts): Disallow whitespace in $UR.
  BM=
fi

ISSR=
while read LINE; do
 case "$LINE" in
  nameserver\ 127.0.0.53) ISSR=1   # systemd-resolved.
 esac
done <"$CONAME".container/rootfs/etc/resolv.conf
if test "$ISSR"; then
  LINE="$(systemd-resolve --status "$NETDEV")"  # Network interface.
  case "$LINE" in
   *DNS\ Servers:\ *) ISSR=2 ;;
  esac
fi
if test "$ISSR" = 2 && test -f "$CONAME".container/rootfs/etc/systemd/resolved.conf; then
  # Copy over host systemd-resolved config to container.
  echo "$LINE" | perl -ni -we 'use integer; use strict; our %conf; our %confhad; BEGIN { $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = ""; while (<STDIN>) { s@^\s+@@; if (s@(.*?): @@) { $key = $1 } chomp; if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ } }; $conf{LLMNR} = "no" } $_ .= "\n" if !m@\n@; if (m@^#?([^\s#=]+)=@ and exists($conf{$1})) { print "$1=$conf{$1}\n"; $confhad{$1} = 1 } else { print } END { for (sort(keys(%conf))) { print "$_=$conf{$_}\n" if !exists($confhad{$_}) } }' "$CONAME".container/rootfs/etc/systemd/resolved.conf || exit 2
  # TODO(pts): Fix non-systemd `nameserver' also in /etc/resolv.conf
fi

(ip -o addr show hostnet 2>/dev/null | while read A B C D E; do
  if test "$B" = hostnet && test "$C" = inet && test "$D" != "$HOSTNETIP/32"; then
    echo "fatal: device hostnet already up, with IP address ${D%/*}, should be: $HOSTNETIP" >&2
    exit 2
  fi
done) || exit 2

if ! ip link show hostnet >/dev/null 2>&1; then
  # https://unix.stackexchange.com/q/622914
  # `type macvlan' works on Etherenet only (no wifi), `type ipvlan mode l2' works everywhere.
  # ipvlan vs macvlan: https://sreeninet.wordpress.com/2016/05/29/macvlan-and-ipvlan/
  # ip link del hostnet ||:
  ip link add hostnet link "$NETDEV" type ipvlan mode l2 || exit 2
  ip addr add "$HOSTNETIP"/32 brd + dev hostnet || exit 2
  ip link set hostnet up || exit 2  # `ip route add' below needs it.
fi

GUESTNETNS=guest."$CONAME"
#ip netns del "$GUESTNETNS" && sleep .5 ||:
if ! (ip netns list | while read A B; do test "$A" = "$GUESTNETNS" && exit 0; done); then
  # Network namespace $GUESTNETNS doesn't exist, create it.
  ip netns add "$GUESTNETNS" || exit 2
  ip -n "$GUESTNETNS" link set lo up || exit 2
  # Needed by Docker.
  echo 1 | ip netns exec guest.co92 tee /proc/sys/net/ipv4/ip_forward >/dev/null || exit 2
fi

GUESTIP=
read GUESTIP <"$CONAME".container/ipaddr 2>/dev/null ||:

ip link del "$GUESTNETNS"in 2>/dev/null ||:
ip -n "$GUESTNETNS" link del "$GUESTNETNS"in 2>/dev/null ||:
if test "$GUESTIP"; then
  ip link add link "$NETDEV" name "$GUESTNETNS"in type ipvlan mode l2 || exit 2
  ip link set "$GUESTNETNS"in netns "$GUESTNETNS" || exit 2
  ip -n "$GUESTNETNS" addr add "$GUESTIP/$NETMASKBITS" brd + dev "$GUESTNETNS"in || exit 2
  ip -n "$GUESTNETNS" link set "$GUESTNETNS"in up || exit 2
  ip -n "$GUESTNETNS" route add default via 192.168.0.1 || exit 2
  test "$(ip route show "$GUESTIP"/32)" && ip route del "$GUESTIP"/32
  ip route add "$GUESTIP"/32 dev hostnet || exit 2
fi

exec 9>"$CONAME".container/console.out.tmp </dev/null
# Docker needs --capability=CAP_SYS_MODULE,CAP_NET_ADMIN
# Docker needs --bind /proc/sys/net/ipv4 for .../ip_forward
#   SUXX: no effect, mounted before /proc/sys
#   --bind /proc/sys/net/ipv4 \
# SUXX: echo 1 >/proc/sys/net/ipv4/ip_forward ||:  # For Docker.
systemd-nspawn --boot --directory "$CONAME".container/rootfs \
    $BM --network-namespace-path /var/run/netns/guest."$CONAME" \
    --capability=CAP_SYS_MODULE,CAP_NET_ADMIN \
    --bind=/sys/fs/cgroup \
    --machine "$CONAME" >&9 2>&9 &
exec 9>&1
while ! read LINE <"$CONAME".container/console.out.tmp; do :; done
E=
#if machinectl show -- "$CONAME" >/dev/null; then
#read LINE <"$CONAME".container/console.out.tmp || exit 1
case "$LINE" in
 Directory\ tree\ *\ is\ currently\ busy*) E=1 ;;
 Spawning\ *) ;; *) E=2 ;;
esac
#else
#  E=1
#fi
if test "$E"; then
  if test "$E" = 1; then
    # TODO(pts): Also check it by name with a different directory.
    echo "info: shoutdown gracefully: sudo machinectl poweroff $CONAME" >&2
    echo "fatal: container already running: $CONAME" >&2
  else
    cat "$CONAME".container/console.out.tmp >&2
    rm -f "$CONAME".container/console.out.tmp
  fi
  exit 2
fi
mv "$CONAME".container/console.out.tmp "$CONAME".container/console.out

# Perhaps it's too early (race condition) for poweroff or shell now.
echo "info: started; shutdown gracefully: sudo machinectl poweroff $CONAME" >&2
echo "info: view console: less '$CODIR/$CONAME.container/console.out'" >&2
echo "info: root shell: sudo machinectl shell $CONAME" >&2
exit 0
