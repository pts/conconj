#!/bin/sh --
#
# conconj: Contaniner Conjurer
# by pts@fazekas.hu at Mon Dec  7 14:58:29 CET 2020
#
# Tested on host system: Ubuntu 18.04.
#
# TODO(pts): sudo apt-get install -y systemd-container  # For systemd-nspawn. Sometimes (on Debian 7?) it's in the systemd package.
# TODO(pts): sudo apt-get install -y iproute2  # For ip.
# TODO(pts): sudo apt-get install -y iptables  # For iptables.
# TODO(pts): in-container: sudo apt-get install systemd-sysv
# TODO(pts): in-container: sudo apt-get install -y kmod  # For modprobe. To get rid of systemd startup errors. Also strongly recommended for docker.
# TODO(pts): in-container: sudo apt-get install -y iputils-ping  # For ping. (But busybox can also have it.)
# TODO(pts): in-container: sudo apt-get install -y docker.io kmod  # For docker.
# TODO(pts): systemd-nspawn --notify-ready=
# TODO(pts): doc: if the network interface (or link?) is down, then containers on hostnet cannot communicate either
# TODO(pts): (doc and check) on non-systemd containers (such as Alphine Linux), the shell command fails with: Failed to get shell PTY: Protocol error -- because systemd uses D-Bus to get the PTY; use Unix-domain sockat with socat
#            socat server: env -i HOME="$HOME" TERM="$TERM" socat TCP-LISTEN:1337,reuseaddr,fork SYSTEM:'read X; echo "/$X/";exec /bin/bash -l',stderr,pty,setsid
#            socat client: socat file:`tty`,raw,echo=0 tcp:127.0.0.1:1337
#            SUXX: doesn't transfer $TERM, doesn't transfer stty -a: rows 24; columns 80
# TODO(pts): doc: document networking
# TODO(pts): `machinectl terminate ...' instead of `machinectl kill ... -s 9'
# !! TODO(pts): umount /tmp if configured -- or add /etc/rc.local to container /etc/profile + systemd?
# !! TODO(pts): upon poweroff, detect busybox, and automatically send SIGUSR2
# !! TODO(pts): Copy over LANG, LC_* etc. to container for the `shell' and start-shell commands if it has locale installed.
# !! TODO(pts): don't follow symlinks up when overwriting files in container rootfs
# !! TODO(pts): Test DNS and Docker in Debian 7 (sysvinit).
# !! TODO(pts): doc: Debian: this is normal: -- make it optional
#               Failed to mount n/a on /tmp/runc/co18.container/rootfs/sys/fs/selinux (MS_BIND ""): No such file or directory
#               Failed to mount n/a on /tmp/runc/co18.container/rootfs/sys/fs/selinux (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_REMOUNT|MS_BIND ""): Invalid argument
# !! TODO(pts): why needed after: apt-get install docker? systemctl start docker; also for openssh-server; solution: rm /usr/sbin/policy-rc.d
# !! TODO(pts): The --bind /shared directory.
# !! TODO(pts): timezone -- which packages are needed?
# !! TODO(pts): /etc/default/locale ?
# !! TODO(pts): Add "$HOSTNETIP host" or "$LOCALNETIP host" to /etc/hosts , also copy from/to host /etc/hosts
#

if test -z "$CONCONJ_RERUN" && ! (test $# = 0 || test "$1" = --help); then
  unset S
  # TODO(pts): Display help as non-root (without sudo).
  test "$(id -u)" != 0 && S='sudo --'
  exec $S /usr/bin/env -i TZ="$TZ" TERM="$TERM" CONCONJ_RERUN=1 CONCONJ_UNSAFE_IPTABLES_RESET="$CONCONJ_UNSAFE_IPTABLES_RESET" /bin/sh "$0" "$@"
  exit 1
fi

CMD=
if test "$1" = start || test "$1" = shell || test "$1" = start-shell || test "$1" = login || test "$1" = poweroff ||  test "$1" = stop || test "$1" = kill || test "$1" = pts-debootstrap || test "$1" = show; then
  if test $# != 1; then
    CMD="$1"; CONAME="$2"; shift; shift
  fi
  test "$CMD" = poweroff && CMD=stop  # Alias.
elif test "$1" = list || test "$1" = delnet; then
  CMD="$1"; shift
elif test $# = 1 && test "${1#-}" = "$1"; then
  CMD=start; CONAME="$1"; shift
fi
if test "$CMD" = start || test "$CMD" = login || test "$CMD" = stop || test "$CMD" = show; then
  test $# != 0 && CMD=  # Too many command-line arguments.
fi
if ! test "$CMD"; then
  echo "\
$0: Container Conjurer (conconj)
Usage: $0 [start] <container-name>
       $0 shell <container-name>  # Root shell.
       $0 start-shell <container-name>  # Start, run root shell as PID 1.
       $0 show <container-name>
       $0 stop <container-name>  # Gracefully, but don't wait for shutdown.
       $0 kill <container-name> [<arg> ...]
       $0 kill <container-name> -s 9  # Force kill (SIGKILL) all processes.
       $0 login <container-name>
       $0 list  # List active containers.
       $0 pts-debootstrap <container-name> [<arg> ...] <debian-dist>  # Create new container rootfs with Debian, Ubuntu etc.
       $0 delnet  # Delete network interfaces and rules." >&2
  exit 1
fi

CODIR="${0%/*}"
cd "$CODIR" || exit 2

if test "$CMD" = list; then
  type machinectl >/dev/null 2>&1 && exec machinectl "$CMD" "$@"
  MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install systemd-container"
  echo "fatal: command machinectl not found$MSG" >&2
  exit 2
fi

if test "$CMD" = delnet; then
  if test $# != 0; then
    echo "fatal: too many command-line arguments for: $CMD" >&2
    exit 1
  fi
  A=0
  for DEV in cc-localnet cg-localnet cb-localnet cc-hostnet; do
     test "$(ip link show dev "$DEV" 2>/dev/null)" && ! ip link del dev "$DEV" && A=2
  done
  # These commands above have removed conconj routes displayed by `ip route show'.
  #
  # We don't do `echo 0 >/proc/sys/net/ipv4/ip_forward', because the
  # original value is lost.
  #
  # Also we don't do `iptables -P FORWARD DROP', because the original value
  # is lost.
  if type iptables-save >/dev/null 2>&1 &&
     type iptables-restore >/dev/null 2>&1 &&
    read LOCALNETIP 2>/dev/null <conconj.localnet && test "$LOCALNETIP"; then
    # Sync this with the iptables-save code below.
    LINE="$(iptables-save | NIM="${LOCALNETIP%.*}.0/24" perl -we '
        use integer; use strict;
        my $nim = $ENV{NIM}; my $table = ""; my $out = ""; my $chg = 0;
        while (<STDIN>) {
          if (m@^[*](.*)$@) { $table = $1 }
          elsif ($table eq "filter") { if (m@^-A FORWARD(?= ).* -[io] cc-localnet @) { $chg = 1; next } }  # Remove old conconj localnet rule.
          elsif ($table eq "nat") { if (m@^-A POSTROUTING -s \Q$nim ! -d $nim @) { $chg = 1; next } }  # Remove old conconj localnet rule.
          $out .= $_;
        }
        print $out if $chg;
        ')"
     echo "$LINE" | iptables-restore || A=2
  fi
  exit "$A"
fi

case "$CONAME" in
 -* | *[!-._a-zA-Z0-9]* | "") echo "fatal: bad container name: $CONAME"; exit 1 ;;
esac

if test "$CMD" = pts-debootstrap; then
  if type wget >/dev/null 2>&1; then
    DOWNLOAD="wget --no-check-certificate -qO-"
  elif type curl >/dev/null 2>&1; then
    DOWNLOAD="curl -fskL"
  else
    echo "fatal: downloader wget or curl not found" >&2
    exit 3
  fi
  for F in pts-debootstrap; do
    if ! test -f "$F"; then
      BASE_URL=https://raw.githubusercontent.com/pts/pts-debootstrap/master
      $DOWNLOAD "$BASE_URL"/"$F" >"$F".tmp
      if test $? != 0 || ! test -s "$F".tmp; then
        echo "fatal: download failed: $BASE_URL/"$F"" >&2
        exit 3
      fi
      mv "$F".tmp "$F" || exit 3
      chmod +x "$F" || exit 3
    fi
    test -x "$F" || chmod +x "$F" || exit 3
  done

  test -d "$CONAME".container || mkdir "$CONAME".container || exit 2
  if test -d "$CONAME".container/rootfs; then
    echo "fatal: container rootfs directory already exists, not clobbering: $CONAME.container/rootfs" >&2
    exit 2
  fi
  # `shared' is the easiest to set up, doesn't need IP addresses or iptables(8).
  test -f "$CONAME".container/ipaddr || echo shared >"$CONAME".container/ipaddr || exit 2
  echo "info: downloading and installing distro to: $CONAME.container/rootfs" >&2
  exec ./pts-debootstrap --include=dbus --arch amd64 "$@" "$CONAME".container/rootfs; exit 2
fi

if test "$CMD" = start || test "$CMD" = shell || test "$CMD" = start-shell; then
  if machinectl show "$CONAME" 2>/dev/null >&2; then  # Early exit.
    if test "$CMD" != shell; then
      echo "info: shutdown gracefully: $0 stop $CONAME" >&2
      echo "info: force kill: $0 kill $CONAME -s 9" >&2
      echo "fatal: container already running: $CONAME" >&2
      exit 2
    fi
  elif test "$CMD" != start; then
    CMD=start-shell
    if test $# != 0 && test "${1#/}" = "$1"; then
      # For compatibility with `machinectl shell'.
      echo "fatal: shell command must start with /: $1" >&2
      exit 1
    fi
  fi
fi

case "$CMD:$#" in
 shell:0 | start-shell:0)
  if test -f "$CONAME".container/rootfs/bin/bash; then
    # machinectl systemd 232 doesn't autodetect /bin/bash.
    set /bin/sh -c 'cd; exec /bin/bash -l'
  else  # dash and busybox sh don't use /dev/console by default.
    # Error messages without this fix:
    # -sh: can't access tty; job control turned off
    # -sh: can't open /dev/tty: No such device or address
    test "$CMD" = start-shell && set /bin/sh -c 'exec <>/dev/console >&0 2>&0; cd; exec /bin/sh -l'
  fi ;;
 start-shell:[1-9]*)
  # Set up networking first, for consistency and apt-get install.
  set /bin/sh -c 'exec <>/dev/console >&0 2>&0; cd; . /etc/profile; exec "$@"' 0 "$@"
esac
if test "$CMD" != start && test "$CMD" != start-shell; then
  if test "$CMD" = stop; then
    case "$(readlink "$CONAME".container/rootfs/sbin/init)" in
     *systemd*) ;;  # Typically /lib/systemd/systemd .
     *busybox*) CMD=kill; set x -s USR2 --kill-who=leader; shift ;;
     *) if test -f "$CONAME".container/rootfs/sbin/initctl ||
           (test -f "$CONAME".container/rootfs/etc/inittab &&
            perl -e 'while (<STDIN>) { exit(0) if m@^pf::powerwait:/sbin/shutdown\s@ } exit(1)' <"$CONAME".container/rootfs/etc/inittab  # Debian 7 sysvinit /etc/inittab modified by conconj.
           ); then
          # We could also detect /sbin/upstart-file-bridge .
          CMD=kill; set x -s PWR --kill-who=leader; shift
          if test -f "$CONAME".container/rootfs/sbin/initctl; then
            # On Ubuntu 14.04, the `Killing all remaining processes...' phase is slow.
            echo "warning: upstart may need 10 seconds to stop" >&2
          else
            # On Debian 7, it takes 3 seconds to do ``Will now halt.''
            echo "warning: sysvinit may need 3 seconds to stop" >&2
          fi
        else
          echo "fatal: init system not detected, no way to stop; try: $0 kill $CONAME -s 9" >&2; exit 2
        fi
        # FYI `-s INT' to init typically does a reboot, but that fails due to a bug with network namespaces: ``Failed to resolve interface cc.deb7: No such device''.
        # FYI `machinectl shell "$CONAME" /sbin/shutdown -hP now' may work in sysvinit and upstart (Ubuntu 14.04) as well, but `machinectl shell' and `systemd-run -M' need systemd in the container.
        ;;
    esac
  fi
  type machinectl >/dev/null 2>&1; A=$?
  if test "$CMD" = shell && test "$A" = 0; then
    machinectl "$CMD" "$CONAME" "$@"; A=$?
    if test "$A" != 0; then
      # Do some diagnostics.
      B="$(busctl --machine "$CONAME" call org.freedesktop.systemd1 /org/freedesktop/systemd1 org.freedesktop.systemd1.Manager StartTransientUnit 2>&1)"
      case "$B" in
       "Failed to connect to bus: Host is down")
        echo "fatal: container has not been started" >&2; exit 2 ;;
       "Failed to connect to bus: Protocol error")
        if test -f "$CONAME".container/rootfs/bin/dbus-daemon ||
           test -f "$CONAME".container/rootfs/usr/bin/dbus-daemon; then
          echo "fatal: dbus-daemon needed by shell is installed but not running in container" >&2
        else
          MSG=; test -f "$CONAME".container/rootfs/etc/debian_version && MSG="; stop it, and then run this in the container: sudo apt-get update; sudo apt-get install dbus"
          echo "fatal: dbus-daemon needed by shell is not installed in container$MSG" >&2
        fi
        exit 2 ;;
       "The name "*" was not provided"* | "No such interface "*)
        echo "fatal: systemd needed by shell is not installed or not running in container" >&2; exit 2 ;;
       "No such method "*)
        echo "fatal: systemd needed by shell in container is too old, shell won't work while it is running; stop it first" >&2; exit 2 ;;
       *"busctl: "*"not found" | *"not found: busctl")
        echo "fatal: error starting shell (see error message above), diagnostics tool busctl not available" >&2; ;;  # Do not exit.
       "Invalid arguments "*"ssa("*)
        B="$(machinectl "$CMD" "$CONAME" / 2>&1)"
        case "$B" in
         *" PTY: Cannot set property "*", or unknown property"*)  # Property is: StandardInputFileDescriptor.
          echo "fatal: systemd needed by shell in container is too old, shell won't work while it is running; stop it first, or try login instead of shell" >&2; exit 2 ;;
        esac
        echo "fatal: see error message above" >&2 ;;  # Do not exit.
       *)
        echo "error: $B" >&2
        echo "fatal: see error messages above" >&2; exit 2 ;;
      esac
    fi
    exit "$A"
  fi
  exec machinectl "$CMD" "$CONAME" "$@"
  MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install systemd-container"
  echo "fatal: command machinectl not found$MSG" >&2
  exit 2
fi
set x -- "$@"; shift

if ! systemd-nspawn --version >/dev/null 2>&1; then
  # TODO(pts): On older systems (e.g. Debian 7), it's apt-get install systemd.
  MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install systemd-container"
  echo "fatal: command systemd-nspawn doesn't work$MSG" >&2
  exit 2
fi
if ! test -f "busybox.conconj" || ! test -x "busybox.conconj"; then
  echo "fatal: executable not found: $CODIR/busybox.conconj"
  exit 2
fi
if ! test -d "$CONAME.container/rootfs"; then
  echo "fatal: missing rootfs directory in container: $CODIR/$CONAME.container/rootfs"
  exit 2
fi
if ! test -f "$CONAME.container/rootfs/bin/sh"; then
  echo "fatal: missing shell in container: $CODIR/$CONAME.container/rootfs/bin/sh"
  exit 2
fi
export PERL_BADLANG=x  # Unnecessary, because LC_* is unset.
if ! perl -e0 2>/dev/null; then
  MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install perl-base"
  echo "fatal: command perl doesn't work$MSG" >&2
  exit 2
fi
CONIP=
read CONIP <"$CONAME".container/ipaddr 2>/dev/null ||:
HOSTNETIP=; LOCALNETIP=
case "$CONIP" in
 private | shared) ;;
 [1-9]*) HOSTNETIP=. ;;
 local.[1-9]*) LOCALNETIP=. ;;
 "") echo "fatal: missing per-container ipaddr config file: $CODIR/$CONAME.container/ipaddr" >&2; exit 2 ;;
 *) echo "fatal: bad IP address syntax in per-contaier ipaddr config file: $CONAME.container/ipaddr: $CONIP" >&2; exit 2 ;;
esac
if test "$HOSTNETIP" && ! read HOSTNETIP 2>/dev/null <conconj.hostnet; then
  echo "fatal: missing or empty: $CODIR/conconj.hostnet"
  exit 2
fi
LOCALNET4HOSTNETIP=
test "$HOSTNETIP" && read LOCALNET4HOSTNETIP 2>/dev/null <conconj.localnet
if test "$LOCALNETIP" && ! read LOCALNETIP 2>/dev/null <conconj.localnet; then
  echo "fatal: missing or empty: $CODIR/conconj.localnet"
  exit 2
fi
# With localfwd disabled, localnet containers can connect to each other and
# to the host (using the localnet gateway IP address of the host), but not
# anywhere else. With localfwd enabled, containers can also connect to
# anywhere else (using IP forwarding, IP masquerading and IP connection
# tracking; connections will be seen from an IP address of the
# host; connections to hostnet containers will be seen from the
# localnet container IP address) including hosts on the internet and
# hostnet containers, and hostnet containers can also connect to localnet
# containers, but connecting back from internet hosts to localnet containers
# doesn't work (except possibly with UDP hole punching).
LOCALFWD=
test "$LOCALNETIP" && read LOCALFWD 2>/dev/null <conconj.localfwd  # TODO(pts): Ignore trailing whitespace.
case "$LOCALFWD" in 0 | no | false | disable | disabled) LOCALFWD= ;; *) LOCALFWD=1 ;; esac
if test "$HOSTNETIP" || test "$LOCALNETIP"; then
  if ! ip route >/dev/null 2>&1; then
    MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install iproute2"
    echo "fatal: command ip doesn't work$MSG" >&2
    exit 2
  fi
fi
if test "$LOCALFWD"; then
  if ! iptables --version >/dev/null 2>&1; then
    MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install iptables"
    echo "fatal: command iptables doesn't work$MSG" >&2
    exit 2
  fi
  if test -z "$CONCONJ_UNSAFE_IPTABLES_RESET"; then
    for A in iptables-save iptables-restore; do
      if ! type "$A" >/dev/null 2>&1; then
        MSG=; test -f /etc/debian_version && MSG=", try: sudo apt-get install iptables"
        echo "fatal: command $A doesn't work$MSG" >&2
        exit 2
      fi
    done
  fi
fi


# ---

chown 0.0 "$CONAME".container/rootfs || exit 2

# TODO(pts): Don't do these if "$CONIP" = private etc. (?)
NETGATEWAY="$(ip route | while read A B C D; do
      if test "$A" = default && test "$B" = via; then
        case "$C" in *[!0-9.]*) ;; *) echo "$C"; break ;; esac
      fi
    done)"
NETDEVIP="$HOSTNETIP"
test "$NETDEVIP" || NETDEVIP="$NETGATEWAY"
NETDEV=; NETMASKBITS=; NETMASK=;
if test "$NETDEVIP"; then
  # Example: NETDEVIP=192.168.0.90 NETDEV=wlp2s0
  NETDEV="$(ip -o addr | perl -we 'use integer; use strict;
      die "fatal: bad netdevip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@;
      my $netdevip = unpack("N", pack("C4", $1, $2, $3, $4));
      my $netdev; my $netmaskbits; my $netmask;
      while (<STDIN>) { chomp; my @l = split; if (@l > 3 and $l[2] eq "inet" and $l[1] ne "lo" and $l[3] =~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)/(\d+)\Z(?!\n)@ and $5 != 32 and $5 >= 8 and $5 <= 32 and $l[1] ne "cc-localnet") {
        my $ip = unpack("N", pack("C4", $1, $2, $3, $4)); my $mask = unpack("N", pack("N", -1 << (32 - $5))); if (($ip & $mask) == ($netdevip & $mask)) {
          die "fatal: multiple network devices for netdevip: $ARGV[0]\n" if defined($netdev);  # The $5 != 32 check above ensures that cc-hostnet is ignored here.
          $netdev = $l[1]; $netmaskbits = $5; $netmask = $mask; } } }
      die "fatal: missing network device for netdevip: $ARGV[0]\n" if !defined($netdev);
      $netmask = join(".", unpack("C4", pack("N", $netmask)));
      print "NETDEV=\x27$netdev\x27; NETMASKBITS=\x27$netmaskbits\x27; NETMASK=\x27$netmask\x27\n"' -- "$NETDEVIP")"
  test "$NETDEV" || exit 2
  eval "$NETDEV"  # Set NETDEV=...; NETMASKBITS=...; NETMASK=...
  test "$NETDEV" || exit 2
  test "$NETMASKBITS" || exit 2
  test "$NETMASK" || exit 2
fi
HOSTNETDEV="$NETDEV"; HOSTNETMAC=
if test "$LOCALNETIP"; then
  perl -e 'die "fatal: bad localnetip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@' -- "$LOCALNETIP" || exit 2
  NETDEV=; NETMASKBITS=24; NETMASK=255.255.255.0
  NETNETIP="${LOCALNETIP%.*}.0"; CONIP="${LOCALNETIP%.*}.${CONIP##*.}"
  NETGATEWAY=; test "$LOCALFWD" && NETGATEWAY="$LOCALNETIP"
  if test "$NETNETIP" = "$LOCALNETIP" || test "$NETNETIP" = "$CONIP" || test "$LOCALNETIP" = "$CONIP"; then
    echo "fatal: IP addresses must be different: net=$NETNETIP host=$LOCALNETIP container=$CONIP" >&2
    exit 2
  fi
  if test "$LOCALFWD"; then
    HOSTNETMAC="$(ip -o link show dev "$HOSTNETDEV" | perl -wne 'if (m@ link(?:/\S+)? +((?:[0-9a-f]{2}:){5}[0-9a-f]{2})\s@) { print "$1\n"; last }')";
  fi
fi
if test "$LOCALNET4HOSTNETIP"; then
  perl -e 'die "fatal: bad localnetip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@' -- "$LOCALNET4HOSTNETIP" || exit 2
  LOCALNETNET4HOSTNETIP="${LOCALNET4HOSTNETIP%.*}.0"; LOCALNETMASK4HOSTNET=255.255.255.0
fi

BM=
if test -e "$CONAME".container/rootfs/sbin/modprobe; then
  # !! TODO(pts): Disable this if CAP_SYS_MODULE is not used.
  UR=
  read UR </proc/sys/kernel/osrelease  # It's OK to fail.
  if test "$UR" && test -d /lib/modules/"$UR"; then
    # TODO(pts): Disallow whitespace in $UR.
    BM="--bind-ro /lib/modules/$UR"
  fi
fi

if test "$CONIP" = private || (test "$LOCALNETIP" && test -z "$LOCALFWD"); then
  LINE=""  # No DNS servers in the container please.
else
  ISSR=
  while read A B C; do
    if test "$A" = nameserver; then
      # 127.0.1.1 (and others) indicates dnsmasq, 127.0.0.53 indicates systemd-resolved.
      case "$B" in 127.0.0.53) ISSR=2; break ;; 127.0.*) ISSR=1; break ;; esac
    fi
  done </etc/resolv.conf
  if test "$ISSR"; then  # Local DNS servers are listed in /etc/resolv.conf.
    if test "$ISSR" = 2; then  # systemd-resolved.
      # systemd-resolve: systemd 237, Ubuntu 18.04
      # resolvectl: systemd 245.4, Ubuntu 20.04
      LINE="$(systemd-resolve --status "$HOSTNETDEV" 2>/dev/null || resolvectl --status "$HOSTNETDEV" 2>/dev/null)"  # Network interface.
      case "$LINE" in
       *DNS\ Servers:\ *) ISSR= ;;
       *) ISSR=1 ;;  # Fall back to NetworkManager.
      esac
    fi
    if test "$ISSR" = 1; then  # NetworkManager (can be dnsmasq, systemd-resolved or manual).
      # https://askubuntu.com/a/1298994
      # This works in Ubuntu >=15.04. For Ubuntu 14.04, see command on the answer link above.
      # Example output of nmcli: 12.34.56.78 | 90.123.45.6
      LINE="$(nmcli -f IP4.DNS -t -m tabular dev show 2>/dev/null |
          perl -ne 'if (m@^\d+(?=[.])[\d. |]+[.]\d+$@) { chomp; for (split(m@ *[|] *@, $_)) { print "nameserver $_\n" } }')"
      test "$LINE" && ISSR=
    fi
    if test "$ISSR"; then
      echo "fatal: local DNS server found ($B), could not figure out real DNS servers" >&2
      exit 2
    fi
  else
    LINE="$(cat /etc/resolv.conf)"
  fi
fi
# Now "$LINE" contains the DNS configuration of the host.
# TODO(pts): Add a config option to keep it unmodified.

# Example: ../run/systemd/resolve/stub-resolv.conf
RCL="$(readlink "$CONAME".container/rootfs/etc/resolv.conf)"
if test "$RCL"; then
  A=; case "$RCL" in ../*) A="${RCL#*/}" ;; esac
  test "$A" && case "$A/" in */../*) A="" ;; esac  # Safety.
  case "$A" in
   run/systemd/resolve/*) test -d "$CONAME".container/rootfs/run/systemd/resolve || mkdir -p "$CONAME".container/rootfs/run/systemd/resolve || exit 2; RCL= ;;
   run/resolvconf/*) test -d "$CONAME".container/rootfs/run/resolvconf || mkdir -p "$CONAME".container/rootfs/run/resolvconf || exit 2; RCL= ;;
  esac
fi

if ! test "$RCL"; then  # Container /etc/resolv.conf is not a symlink or it is a systemd symlink.
  : >>"$CONAME".container/rootfs/etc/resolv.conf.container  # Create it if needed.
  # Copy over host resolve config to container /etc/resolv.conf.container.
  echo "$LINE" | perl -ni -0777 -we '
      use integer; use strict; our %conf; our %confhad;
      BEGIN {
        $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = "";
        local $/ = "\n";
        while (<STDIN>) {
          s@^\s+@@;
          if (s@(.*?): @@) { $key = $1 } elsif (s@^nameserver\s+@@) { $key = "DNS Servers" }
          chomp; next if !length or m@^#@;
          if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ }
        }
        $conf{LLMNR} = "no";
      }
      my $infile = $_;
      while ($infile =~ m@\G(\n|.+\n?)@gc) {
        $_ = $1;
        $_ .= "\n" if !m@\n@; if (m@^nameserver\s+@ and exists($conf{DNS})) { if (!exists($confhad{DNS})) { for my $dns (split(/ /, $conf{DNS})) { print "nameserver $dns\n" } $confhad{DNS} = 1 } } else { print }
      }
      if (exists($conf{DNS}) and !exists($confhad{DNS})) { for my $dns (split(/ /, $conf{DNS})) { print "nameserver $dns\n" } }
  ' "$CONAME".container/rootfs/etc/resolv.conf.container || exit 2
  # Container /etc/resolv.conf may get overwritten by systemd-nspawn at container startup.
  cat <"$CONAME".container/rootfs/etc/resolv.conf.container >"$CONAME".container/rootfs/etc/resolv.conf || exit 2
fi

# TODO(pts): Security: don't follow symlinks.
#
# The file "$CONAME".container/rootfs/etc/systemd/resolved.conf is user-editable.
if test -f "$CONAME".container/rootfs/etc/systemd/resolved.conf; then
  # Copy over host resolve config to container /etc/systemd/resolved.conf.
  echo "$LINE" | perl -ni -0777 -we '
      use integer; use strict; our %conf; our %confhad;
      BEGIN {
        $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = "";
        local $/ = "\n";
        while (<STDIN>) {
          s@^\s+@@;
          if (s@(.*?): @@) { $key = $1 } elsif (s@^nameserver\s+@@) { $key = "DNS Servers" }
          chomp; next if !length or m@^#@;
          if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ }
        }
        $conf{LLMNR} = "no";
      }
      my $infile = $_;
      while ($infile =~ m@\G(\n|.+\n?)@gc) {
        $_ = $1;
        $_ .= "\n" if !m@\n@; if (m@^#?([^\s#=]+)=@ and exists($conf{$1})) { print "$1=$conf{$1}\n"; $confhad{$1} = 1 } else { print }
      }
      for (sort(keys(%conf))) { print "$_=$conf{$_}\n" if !exists($confhad{$_}) }
  ' "$CONAME".container/rootfs/etc/systemd/resolved.conf || exit 2
fi

# This affects the `shell' command, which starts a login shell.
: >>"$CONAME".container/rootfs/etc/profile || exit 2  # Create if needed.
perl -pi -0777 -we '
    my $cmd = qq(if test -f /etc/resolv.conf.container.start; then umount /etc/resolv.conf 2>/dev/null; rm -f /etc/resolv.conf; cat </etc/resolv.conf.container >/etc/resolv.conf; rm -f /etc/resolv.conf.container.start; :; fi  #conconj\n) .
              qq(if test -f /etc/netup.container; then (. /etc/netup.container); rm -f /etc/netup.container; fi  #conconj\n) .
              qq(/etc/busybox.conconj stty -echoprt -imaxbel </dev/tty >&0  #conconj\n) .  # Workaround for \.../ on backspace in `machinectl shell`.
              qq(test -f /bin/ping || test -f /usr/bin/ping || alias ping="/etc/busybox.conconj ping"  #conconj\n) .
              qq(test -f /etc/conconj.host && read HOST </etc/conconj.host  #conconj\n);
    1 while s@\A(.*) #conconj\n@@;
    substr($_, 0, 0) = $cmd;
    ' "$CONAME".container/rootfs/etc/profile || exit 2

# Undo incorrect setup_resolv_conf() magic in systemd-nspawn, which may
# bind-mount or overwrite /etc/resolv.conf .
# This affects the `start' command (--boot).
# There is no simpler workaround for systemd-nspawn in systemd 237.
# systemd 245.4 has systemd-nspawn --resolv-conf-mode=... to affect this.
if test -d "$CONAME".container/rootfs/etc/systemd/system; then
  # https://www.linode.com/docs/guides/start-service-at-boot/
  echo '
[Unit]
Description=Network interfaces in container
DefaultDependencies=no
Conflicts=shutdown.target
After=
Before=systemd-networkd.service container-resolv-conf.service network.target shutdown.target
#Wants= Requires= Requisite=qqsystemd-resolved.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh /etc/netup.rm.container

[Install]
WantedBy=multi-user.target
' >"$CONAME".container/rootfs/etc/systemd/system/container-network.service || exit 2
  rm -f "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-network.service || exit 2
  # Directory missing before `apt-get install systemd-sysv`.
  if test -d "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants; then
    # Equivalent of in-container: systemctl enable container-network.service
    ln -s /etc/systemd/system/container-network.service "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-network.service || exit 2
  fi
  # !! --network-interface= implies --private-network, so systemd-nspawn doesn't try to mess with /etc/resolv.conf, so this hack is not needed.
  #    undo if not needed (--private-network and --network-interface= don't need it).
  echo '
[Unit]
Description=Set up /etc/resolv.conf in container
DefaultDependencies=no
Conflicts=shutdown.target
After=systemd-resolved.service systemd-networkd.service container-network.service
Before=network.target nss-lookup.target shutdown.target
#Wants= Requires= Requisite=qqsystemd-resolved.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh /etc/resolv.conf.container.setup

[Install]
WantedBy=multi-user.target
' >"$CONAME".container/rootfs/etc/systemd/system/container-resolv-conf.service || exit 2
  echo '
if test -f /etc/resolv.conf.container.start; then
  umount /etc/resolv.conf 2>/dev/null
  rm -f /etc/resolv.conf
  # /run/systemd/resolve/resolv.conf contains actual upstream nameservers.
  if test -f /lib/systemd/resolv.conf && (systemd-resolve --status || resolvectl --status) >/dev/null 2>&1; then
    cat </lib/systemd/resolv.conf >/etc/resolv.conf
  else
    cat </etc/resolv.conf.container >/etc/resolv.conf
  fi
  rm -f /etc/resolv.conf.container.start
  :
fi
' >"$CONAME".container/rootfs/etc/resolv.conf.container.setup || exit 2
  #chmod 755 "$CONAME".container/rootfs/etc/resolv.conf.crontainer.setup || exit 2
  rm -f "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-resolv-conf.service || exit 2
  # Directory missing before `apt-get install systemd-sysv`.
  if test -d "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants; then
    # Equivalent of in-container: systemctl enable container-resolv-conf.service
    ln -s /etc/systemd/system/container-resolv-conf.service "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-resolv-conf.service || exit 2
  fi
  # systemctl status container-resolv-conf.service
fi


rm -f "$CONAME".container/rootfs/etc/resolv.conf.container.start || exit 2
if test "$CONIP" = shared; then
  HOST=127.0.0.1
  test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
  echo "#conconj shared" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
  echo "#conconj shared" >"$CONAME".container/rootfs/etc/netup.container || exit 2
  if test -f "$CONAME.container/rootfs/etc/resolv.conf.container"; then
    : >>"$CONAME".container/rootfs/etc/resolv.conf.container.start || exit 2  # Create.
  fi
  # TODO(pts): Disable systemd-resolved in the container, so that it doesn't
  # try to bind on UDP 127.0.0.53:53 (which is probably already used by the
  # host).
  # !! disable systemd-resolved.service, to avoid warning: Dec 09 17:18:41 co92 systemd-resolved[30]: Another process is already listening on TCP socket 127.0.0.53:53.
  #    do we need to bind-mount a dummy one to /lib/systemd/system/systemd-resolved.service -- or does /etc take precedence?
elif test "$CONIP" = private; then
  HOST=
  test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
  echo "#conconj private" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
  echo "#conconj private" >"$CONAME".container/rootfs/etc/netup.container || exit 2
  set x --private-network "$@"; shift
else
  CONNETIF=cc."$CONAME"
  if test "$HOSTNETIP"; then
    HOST="$HOSTNETIP"
    (ip -o addr show cc-hostnet 2>/dev/null | while read A B C D E; do
      if test "$B" = cc-hostnet && test "$C" = inet && test "$D" != "$HOSTNETIP/32"; then
        echo "fatal: device cc-hostnet already up, with IP address ${D%/*}, should be: $HOSTNETIP; fix it with: sudo ip link del dev cc-hostnet" >&2
        exit 2
      fi
    done) || exit 2

    ISMV=
    if ! ip link show dev cc-hostnet >/dev/null 2>&1; then
      # https://unix.stackexchange.com/q/622914
      # `type macvlan' works on Etherenet only (no wifi), `type ipvlan mode l2' works everywhere.
      # ipvlan vs macvlan: https://sreeninet.wordpress.com/2016/05/29/macvlan-and-ipvlan/
      if test "$ISMV" || ! ip link add name cc-hostnet link "$NETDEV" type ipvlan mode l2 2>/dev/null; then
        # Debian 8 doesn't have ipvlan (not even ipvlan.ko), so we fall back
        # to macvlan. Network won't work (not even from host) over wifi.
        ISMV=1
        if ! ip link add name cc-hostnet link "$NETDEV" type macvlan; then
          # If the error message is `RTNETLINK answers: Device or resource
          # busy', then it may be a macvlan--ipvlan incompatibility. Solve it
          # by stopping all containers, then running `sudo ip link del dev ...'
          # on all conconj.... devices including cc-hostnet.
          echo "fatal: error creating network device: cc-hostnet" >&2
          exit 2
        fi
      fi
      ip addr add "$HOSTNETIP"/32 brd + dev cc-hostnet || exit 2
      ip link set cc-hostnet up || exit 2  # `ip route add' below needs it.
      ip addr flush dev cc-hostnet scope link || exit 2  # Remove link-local IPv6 (inet6) address.
    fi
    ip link del "$CONNETIF" 2>/dev/null ||:
    # ip -n "$CONNETNS" link del "$CONNETIF" 2>/dev/null ||:
    # TODO(pts): If everything is all right (includin type ...lan), don't
    # make any changes, so that currently running shells would continue
    # working.
    if test "$ISMV" || ! ip link add name "$CONNETIF" link "$NETDEV" type ipvlan mode l2 2>/dev/null; then
      # Falling back to macvlan, see above.
      ISMV=1
      if ! ip link add name "$CONNETIF" link "$NETDEV" type macvlan; then
        # If the error message is `RTNETLINK answers: Device or resource
        # busy', then it may be a macvlan--ipvlan incompatibility. Solve it
        # by stopping all containers, then running `sudo ip link del dev ...'
        # on all conconj.... devices including cc-hostnet.
        echo "fatal: error creating network device: $CONNETIF" >&2
        exit 2
      fi
    fi
    test "$(ip route show "$CONIP"/32)" && ip route del "$CONIP"/32
    # The route "$HOSTNETIP"/32 isn't added by default, but we don't need it.
    # It would be awesome to remove this route automatically when the container
    # stops, but there is no mechanism for that: it will linger around.
    ip route add "$CONIP"/32 dev cc-hostnet || exit 2
  elif test "$LOCALNETIP"; then
    HOST="$LOCALNETIP"
    # veth + bridge + iptables setup based on: https://superuser.com/a/765078
    # Using busybox to avoid the need for `apt-get install bridge-utils'.
    LINE="$(ip link add cb-localnet type bridge 2>&1)"
    case "$?:$LINE" in
     0: | *:\ File\ exists) ;;
     *) echo "$LINE" >&2; echo "fatal: error creating bridge" >&2; exit 2
    esac
    ip link set cb-localnet up || exit 2  # Doesn't add the route because of noprefixroute above.
    if ! ip link show dev cg-localnet >/dev/null 2>&1 ||
       ! ip link show dev cc-localnet >/dev/null 2>&1; then
      ip link del dev cg-localnet 2>/dev/null ||:
      ip link del dev cc-localnet 2>/dev/null ||:
      ip link add name cg-localnet type veth peer name cc-localnet || exit 2
      if ! ip link set dev cg-localnet master cb-localnet; then
        echo "fatal: error adding cg-localnet to bridge cc-localnet" >&2
        exit 2
      fi
    fi
    LINE=$(ip -o addr show cc-localnet 2>&1 | while read A B C D E; do
          if test "$C" = inet && test "$D" = "$LOCALNETIP"/"$NETMASKBITS"; then echo 1
          elif test "$C" = inet6; then :
          else echo 2
          fi
        done)
    if test "$LINE" = 1; then
      :
    elif test "$LINE"; then
      echo "fatal: device cc-localnet already up, should be: $LOCALNETIP/$NETMASKBITS; fix it with: sudo ip addr flush dev cc-localnet" >&2
      exit 2
    else
      ip addr add "$LOCALNETIP"/"$NETMASKBITS" brd + dev cc-localnet || exit 2
    fi
    ip link set cg-localnet up || exit 2
    ip link set cc-localnet up || exit 2  # Also adds the route. Also adds a link-local IPv6 (inet6) address for cg-localnet (!).
    ip addr flush dev cg-localnet scope link || exit 2  # Remove link-local IPv6 (inet6) address.
    ip addr flush dev cc-localnet scope link || exit 2  # Remove link-local IPv6 (inet6) address.
    # `ip route del' deletes only one route, so we run it in a loop.
    # Adding the route is not needed, `ip link set cc-localnet up' has done it.
    #    while test "$(ip route show "$NETNETIP"/"$NETMASKBITS")"; do ip route del "$NETNETIP"/"$NETMASKBITS"; done
    #    ip route add "$NETNETIP"/"$NETMASKBITS" dev cc-localnet || exit 2

    ip link del dev cg."$CONAME" 2>/dev/null ||:
    ip link del dev "$CONNETIF" 2>/dev/null ||:
    ip link add name cg."$CONAME" type veth peer name "$CONNETIF" || exit 2
    if ! ip link set dev cg."$CONAME" master cb-localnet; then
      echo "fatal: error adding cg.$CONAME to bridge cc-localnet" >&2
      exit 2
    fi
    ip link set cg."$CONAME" up
    #set x --network-interface=cg."$CONAME" "$@"; shift  # Breaks `ping' (even adter ifconfig cg."$CONAME" up), don't do it.
    #ip link set "$CONNETIF" up  # Will be done by busybox in the container.

    if test "$LOCALFWD"; then
      test ! -f /proc/sys/net/ipv4/ip_forward || echo 1 >/proc/sys/net/ipv4/ip_forward || echo 2
      test ! -f /proc/sys/net/bridge/bridge-nf-call-arptables || echo 0 >/proc/sys/net/bridge/bridge-nf-call-arptables || exit 2
      # Without this, bridged packets don't make it to the POSTROUTING chain.
      # There is also bridge-nf-call-ip6tables, but we don't need it.
      test ! -f /proc/sys/net/bridge/bridge-nf-call-iptables || echo 0 >/proc/sys/net/bridge/bridge-nf-call-iptables || exit 2
      # Now we add netfilter rules (with iptables) to the beginning of the
      # `-A FORWARD' and `-t nat -A POSTROUTING' chains. We don't care about
      # the policy (-P) on these chains.
      #
      # TODO(pts): Cooperate with ufw: use `-I ufw-user-forward' instead of
      #     `-I FORWARD'. But there is not equivalent for POSTROUTING. At least
      #     run the iptables commands after ufw has started.
      if test "$CONCONJ_UNSAFE_IPTABLES_RESET"; then  # Specify this in the command-line.
        # This implementation removes all previous rules from the chains it
        # edits (do it's destructive and probably unsafe), but it doesn't
        # change the policy (-P). See the non-destructive (but uncommented)
        # version below.
        iptables -F FORWARD || exit 2
        # Make connections from a hostnet container to a localnet container
        # work. Unfortunately this rule never matches, because the packet has
        # IN=wlp2s0 rather than IN=cc-hostnet. See the next rule for a
        # workaround.
        iptables -A FORWARD -i cc-hostnet -o cc-localnet -d "$NETNETIP"/"$NETMASKBITS" -j ACCEPT || exit 2
        # Make connections from a hostnet container to a localnet container
        # actually work. This is a workaround for the previous rule, it
        # specifies `-m mac --mac-source "$HOSTNETMAC"' instead of `-i
        # hostnet'. It matches only if ipvlan is used (which is the default,
        # except that old systems such as Debian 8 have only macvlan.)
        test "$HOSTNETMAC" && iptables -A FORWARD -o cc-localnet -d "$NETNETIP"/"$NETMASKBITS" -m mac --mac-source "$HOSTNETMAC" -j ACCEPT || exit 2
        # About including INVALID: http://www.smythies.com/~doug/network/iptables_notes/
        iptables -A FORWARD -i cc-localnet -p tcp -m state --state INVALID -j DROP || exit 2
        iptables -A FORWARD -o cc-localnet -d "$NETNETIP"/"$NETMASKBITS" ! -s "$NETNETIP"/"$NETMASKBITS" -m state --state ESTABLISHED,RELATED -j ACCEPT || exit 2
        iptables -A FORWARD -i cc-localnet -s "$NETNETIP"/"$NETMASKBITS" ! -d "$NETNETIP"/"$NETMASKBITS" -j ACCEPT || exit 2
        iptables -t nat -F POSTROUTING || exit 2  # No need to change the default policy to -P ACCEPT
        # Make connections from a localnet container to a hostnet container
        # use the original localnet IP address, without NAT (MASQUERADE).
        iptables -t nat -A POSTROUTING -s "$NETNETIP"/"$NETMASKBITS" ! -d "$NETNETIP"/"$NETMASKBITS" -o cc-hostnet -j ACCEPT || exit 2
        # We don't specify -o "$HOSTNETDEV" here, because it's not restrictive
        # enough, OUTPUT packets also go there.
        iptables -t nat -A POSTROUTING -s "$NETNETIP"/"$NETMASKBITS" ! -d "$NETNETIP"/"$NETMASKBITS" -j MASQUERADE || exit 2
      else
        # Prepend our rules to `-A FORWARD' and `-t nat -A POSTROUTING' chains.
        # This backtracks counters a bit, rewrites chain rules from scratch,
        # but it doesn't change the chain policy (-P).
        # TODO(pts): Be idempotent: don't change it if not needed. (This
        #     depends on some serialization rules (e.g. uppercase $hostnetmac).
        LINE="$(iptables-save | NIM="$NETNETIP/$NETMASKBITS" HOSTNETMAC="$HOSTNETMAC" perl -we '
            use integer; use strict;
            my %tables; my $nim = $ENV{NIM}; my $hostnetmac = uc($ENV{HOSTNETMAC});
            my $hostnetmac_rule = ""; $hostnetmac_rule = "-A FORWARD -d $nim -o cc-localnet -m mac --mac-source $hostnetmac -j ACCEPT" if length($hostnetmac);
            $tables{filter} = qq(
                -A FORWARD -d $nim -i cc-hostnet -o cc-localnet -j ACCEPT
                $hostnetmac_rule
                -A FORWARD -i cc-localnet -p tcp -m state --state INVALID -j DROP
                -A FORWARD ! -s $nim -d $nim -o cc-localnet -m state --state RELATED,ESTABLISHED -j ACCEPT
                -A FORWARD -s $nim ! -d $nim -i cc-localnet -j ACCEPT
            );
            $tables{nat} = qq(
                -A POSTROUTING -s $nim ! -d $nim -o cc-hostnet -j ACCEPT
                -A POSTROUTING -s $nim ! -d $nim -j MASQUERADE
            );
            { for my $table (sort(keys(%tables))) { $tables{$table} =~ s@\n[ \t]+@\n@g; $tables{$table} =~ s@\A\n+@@; $tables{$table} =~ s@\n{2,}@\n@g; 1 while chomp($tables{$table}); $tables{$table} .= "\n" if length($tables{$table}) } }
            { my $table = ""; my $do_print = 0;
              while (<STDIN>) {
                next if m@^#@;
                if (m@^[*](.*)$@) { $table = $1; $do_print = exists($tables{$table}); next if !$do_print; print; print $tables{$table}; delete $tables{$table}; next }
                next if !$do_print;
                if ($table eq "filter") { next if m@^-A FORWARD(?= ).* -[io] cc-localnet @ }  # Remove old conconj localnet rule.
                if ($table eq "nat") { next if m@^-A POSTROUTING -s \Q$nim ! -d $nim @ }  # Remove old conconj localnet rule.
                print;
            } }
            { for my $table (sort(keys(%tables))) { print "*$table\n$tables{$table}COMMIT\n" } }
            ')"
        if test $? != 0 || test -z "$LINE"; then
          echo "fatal: error in iptables-save + rule editing" >&2
          exit 2
        fi
        if ! (echo "$LINE" | iptables-restore); then
          echo "fatal: error in iptables-restore" >&2
          exit 2
        fi
      fi
    fi
  fi
  if test -z "$NETMASK"; then
    echo "assert: \$NETMASK not set" >&2
    exit 2
  fi

  # This file is not used directly, it can be used by manually running `ifup -a'
  # after `sudo apt-get install -y ifupdown'.
  test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
  NETGATEWAYH=; test "$NETGATEWAY" || NETGATEWAYH="#"
  NETGATEWAYLH="#"; test "$NETGATEWAY" && test "$LOCALFWD" && NETGATEWAYLH=
  LOCALNETROUTE=
  test "$LOCALNET4HOSTNETIP" && LOCALNETROUTE="/etc/busybox.conconj route add -net '$LOCALNETNET4HOSTNETIP' netmask '$LOCALNETMASK4HOSTNET' gateway '$HOSTNETIP' || exit \$?"
  LOCALNETROUTEUP='#up conconj-localnet-route'
  test "$LOCALNET4HOSTNETIP" && LOCALNETROUTEUP="up /etc/busybox.conconj route add -net '$LOCALNETNET4HOSTNETIP' netmask '$LOCALNETMASK4HOSTNET' gateway '$HOSTNETIP'"
  echo "#conconj
auto lo
iface lo inet loopback

auto $CONNETIF
iface $CONNETIF inet static
  address $CONIP
  netmask $NETMASK
  ${NETGATEWAYH}gateway $NETGATEWAY
  $LOCALNETROUTEUP
" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
  # Broadcast is enabled by default, no need for `broadcast +'.
  # The `ping -c1' below is a workaround for slow ping startup after restarting
  # a localnet container. Without it, it took 9..17..24 seconds for a
  # hostnet-to-localnet ping to work.
  echo "
/etc/busybox.conconj ifconfig '$CONNETIF' '$CONIP' netmask '$NETMASK' up || exit \$?
${NETGATEWAYH}/etc/busybox.conconj route add default gw '$NETGATEWAY' || exit \$?
${NETGATEWAYLH}/etc/busybox.conconj ping -c1 '$NETGATEWAY' >/dev/null 2>&1 || exit \$?
$LOCALNETROUTE
" >"$CONAME".container/rootfs/etc/netup.container || exit 2
  #cat "$CONAME".container/rootfs/etc/netup.container
  set x --network-interface="$CONNETIF" "$@"; shift
  # Undo incorrect setup_resolv_conf() magic in systemd-nspawn, which may
  # bind-mount or overwrite /etc/resolv.conf .  !! undo if not needed (--private-network and --network-interface= don't need it).
  if test -f "$CONAME.container/rootfs/etc/resolv.conf.container"; then
    : >>"$CONAME".container/rootfs/etc/resolv.conf.container.start || exit 2  # Create.
  fi
fi

#set x --setenv=HOST="$HOST" "$@"; shift  # This doesn't affect command start.
echo "$HOST" >"$CONAME".container/rootfs/etc/conconj.host || exit 2
: >>"$CONAME".container/rootfs/etc/hosts  # Create it if needed.
# Update a few hostnames (%toset) in container /etc/hosts.
env HOST="$HOST" perl -ni -0777 -we '
    use integer; use strict;
    my %toset = ("host" => $ENV{HOST}, "localhost" => "127.0.0.1");
    my %isset;
    my $out = "";
    while (m@\G(\n|.+\n?)@gc) {
      local $_ = $1;
      if (m@^#@ or !m@\S@) { $out .= $_; next }
      $_ .= "\n" if !m@\n@;
      my @l = split(m@\s+@, $_);
      my $has_changed = 0;
      if (@l > 1) {
        my $ip = shift(@l);
        my @r = grep { !(!exists($toset{$_}) or (!exists($isset{$_}) and $toset{$_} eq $ip)) } @l;
        @l = grep {      !exists($toset{$_}) or (!exists($isset{$_}) and $toset{$_} eq $ip) } @l;
        $has_changed = 1 if @r;
        if (!@l and @r == 1 and !exists($isset{$r[0]})) {
          $ip = $toset{$r[0]}; @l = @r;
        }
        for my $h (@l) { $isset{$h} = 1 if exists($toset{$h}) }
        $_ = @l ? "$ip @l\n" : "\n" if $has_changed;
      }
      $out .= $_;
    }
    for my $h (sort(keys(%toset))) {
      $out .= "$toset{$h} $h\n" if !exists($isset{$h});
    }
    print($out);
    ' "$CONAME".container/rootfs/etc/hosts

# !! mount and umount to busybox
# Maybe docker tries to bind-mount /proc to the container (and that won't work):
#   Dec 10 11:58:37 co18 dockerd[98]: time='2020-12-10T11:58:37Z' level=error msg='failed to disable IPv6 forwarding for container's interface all: open /proc/sys/net/ipv6/conf/all/disable_ipv6: read-only file system'
#   (! test -f /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 || mount --bind /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 /proc/sys/net/ipv6/conf/all/disable_ipv6) &&  # For Docker. Doesn't help.
#   (! test -f /etc/proc/sys/net/ipv6/conf || mount --bind /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 /proc/sys/net/ipv6/conf) &&  # For Docker. Doesn't help.
echo "
    if test -f /proc/sys/net/ipv4/ip_forward && ! (: 2>/dev/null >>/proc/sys/net/ipv4/ip_forward); then
      # Workaround for systemd 229: Read-only filesystem.
      test -d /etc/proc || mkdir /etc/proc
      mount proc /etc/proc -t proc &&
      (! test -f /etc/proc/sys/net/ipv4/ip_forward || mount --bind /etc/proc/sys/net/ipv4/ip_forward /proc/sys/net/ipv4/ip_forward) &&  # For Docker.
      (! test -f /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 || mount --bind /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 /proc/sys/net/ipv6/conf/all/disable_ipv6) &&  # For Docker. Doesn't help.
      umount /etc/proc
    fi
" >>"$CONAME".container/rootfs/etc/netup.container || exit 2
echo "
    if test -f /etc/netup.container; then
      (. /etc/netup.container); XC=\$?
      rm -f /etc/netup.container
      exit \$XC
    fi
" >"$CONAME".container/rootfs/etc/netup.rm.container || exit 2
test -d "$CONAME".container/rootfs/etc/default || mkdir "$CONAME".container/rootfs/etc/default || exit 2
# Disable `ifup -a' call in /lib/systemd/system/networking.service
echo 'CONFIGURE_INTERFACES=no
' >"$CONAME".container/rootfs/etc/default/networking || exit 2;
# Broadcast is enabled by default, no need for `broadcast +'.

if test -f "$CONAME".container/rootfs/etc/pam.d/login &&
   perl -e 'while (<>) { exit 0 if m@ pam_securetty[.]so$@ and !m@^#@ } exit 1' "$CONAME".container/rootfs/etc/pam.d/login ; then
  perl -pi -e 's@^(?=[^#])@#@ if m@ pam_securetty[.]so$@' "$CONAME".container/rootfs/etc/pam.d/login || exit 2
fi

# !! Add setting without Docker.
# Docker needs --capability=CAP_SYS_MODULE,CAP_NET_ADMIN .
# --bind=/sys/fs/cgroup is needed by docker.
# --capability=CAP_SYS_MODULE,CAP_NET_ADMIN is needed by Docker, but not by iptables.
# --capability=all is too much, not needed.
# By using --network-interface=... (but not --network-namespace-path=...),
# this is not needed, docker can set it up for itself:
#   echo 1 | ip netns exec "$CONNETNS" tee /proc/sys/net/ipv4/ip_forward >/dev/null || exit 2

BOOTARG=
test "$CMD" = start-shell || BOOTARG=--boot
set x $BOOTARG --directory="$CONAME".container/rootfs \
    $BM --bind-ro="$(pwd)"/busybox.conconj:/etc/busybox.conconj \
    --capability=CAP_SYS_MODULE,CAP_NET_ADMIN \
    --bind=/proc/sys/net/ipv4:/var/ipv4 \
    --bind=/sys/fs/cgroup --machine="$CONAME" "$@"; shift
# With --private-users=no, container systemd freezes with: ``Failed to allocate manager object, freezing.''.
export SYSTEMD_NSPAWN_USE_CGNS=0  # Needed by Docker.

LINE="$(systemd-nspawn --system-call-filter= --directory=/dev/null 2>&1)"
case "$LINE" in *--system-call-filter=*) ;; *) LINE="" ;; esac
SYSTEMD_NSPAWN=systemd-nspawn
if test "$LINE"; then  # Old systemd-nspawn without --system-call-filter=... .
  if ! test -f patch_nspawn.pl; then
    echo "fatal: script not found: $CODIR/patch_nspawn.pl" >&2
    exit 2
  fi
  LINE="$(type systemd-nspawn 2>&1)"
  case "$LINE" in systemd-nspawn\ is\ /*) LINE="${LINE#* is }" ;; *) LINE="" ;; esac
  if test -z "$LINE"; then
    echo "fatal: command not found: systemd-nspawn" >&2
    exit 2
  fi
  # This can patch systemd-nspawn 232 on Debian 9 on Linux amd64.
  if ! perl patch_nspawn.pl "$LINE" systemd-nspawn.docker; then
    echo "fatal: systemd-nspawn does not support --system-call-filter=... , binary patching didn't work" >&2
    exit 2
  fi
  SYSTEMD_NSPAWN="$CODIR"/systemd-nspawn.docker
  set ./systemd-nspawn.docker "$@"
else
  SYSTEMD_NSPAWN=systemd-nspawn
  set "$SYSTEMD_NSPAWN" --system-call-filter="add_key keyctl" "$@"
fi

# This would override $CONAME within the container, so we remove it.
rm -f "$CONAME".container/rootfs/etc/hostname

if test "$CMD" = start-shell; then
  exec "$@"
  echo "fatal: command not found: $1" >&2
  exit 2
fi

if test -f "$CONAME".container/rootfs/etc/inittab; then
  if ! perl -ne 'exit(1) if m@^(?:tty)?\d+:.*getty.*[ t]tty(\d+)$@ or
      (m@^pf::powerwait:@ and m@\n@ and !m@^pf::powerwait:/sbin/shutdown\s@);
      ' <"$CONAME".container/rootfs/etc/inittab; then
    # Prevent busybox init from listening on /dev/tty$N, generating errors.
    # Change Debian 7 `pf::powerwait:/etc/init.d/powerfail start' to shutdown -q.
    perl -pi -e 's@^@#@ if m@^(?:tty)?\d+:.*getty.*[ t]tty(\d+)$@;
        s@^pf::powerwait:.*\n@pf::powerwait:/sbin/shutdown -hP now\n@;
        ' "$CONAME".container/rootfs/etc/inittab || exit 2
  fi
fi

exec 9>"$CONAME".container/console.out.tmp </dev/null
"$@" >&9 2>&9 &  # This generates some shell-specific command-not-found error.
exec 9>&2
while ! read LINE <"$CONAME".container/console.out.tmp; do :; done
E=
case "$LINE" in
 Directory\ tree\ *\ is\ currently\ busy*) E=1 ;;
 Spawning\ *) ;;  # Success (at least so far).
 *:\ not\ found | *:\ command\ not\ found) E=2 ;;
 *) E=0 ;;
esac
if test "$E"; then
  if test "$E" = 1; then  # Already unning.
    echo "info: shutdown gracefully: $0 stop $CONAME" >&2
    echo "info: force kill: $0 kill $CONAME -s 9" >&2
    echo "fatal: container already running: $CONAME" >&2
  elif test "$E" = 2; then
    echo "fatal: command not found: $SYSTEMD_NSPAWN" >&2
  else #elif test "$E" = 0; then
    cat "$CONAME".container/console.out.tmp >&2
    rm -f "$CONAME".container/console.out.tmp
  fi
  exit 2
fi
mv "$CONAME".container/console.out.tmp "$CONAME".container/console.out

# Perhaps it's too early (race condition) for stop or shell now.
echo "info: started; shutdown gracefully: $0 stop $CONAME" >&2
echo "info: force kill: $0 kill $CONAME -s 9" >&2
echo "info: view console: less '$CODIR/$CONAME.container/console.out'" >&2
echo "info: root shell: $0 shell $CONAME" >&2

exit 0
