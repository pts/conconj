#!/bin/sh --
# by pts@fazekas.hu at Mon Dec  7 14:58:29 CET 2020
#
# Tested on host system: Ubuntu 18.04.
#
# TODO(pts): sudo apt-get install -y systemd-container  # For systemd-nspawn.
# TODO(pts): sudo apt-get install -y iproute2  # For ip.
# TODO(pts): in-container: sudo apt-get install systemd-sysv
# TODO(pts): in-container: sudo apt-get install -y kmod  # For modprobe. To get rid of systemd startup errors. Also strongly recommended for docker.
# TODO(pts): in-container: sudo apt-get install -y iputils-ping  # For ping. (But busybox can also have it.)
# TODO(pts): in-container: sudo apt-get install -y docker.io kmod  # For docker.
# TODO(pts): systemd-nspawn --notify-ready=
# !! TODO(pts): Clean up network linterfaces (ip link) upon container exit in both shell and poweroff. (Can the kernel do it by linking them?)
# !! TODO(pts): don't follow symlinks up when overwriting files in container rootfs
# !! TODO(pts): feature: networking mode nat: virtual bridge with NAT
# !! TODO(pts): Test DNS and Docker in Debian 7 (sysvinit).
# !! TODO(pts): doc: Debian: this is normal: -- make it optional
#               Failed to mount n/a on /tmp/runc/co18.container/rootfs/sys/fs/selinux (MS_BIND ""): No such file or directory
#               Failed to mount n/a on /tmp/runc/co18.container/rootfs/sys/fs/selinux (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_REMOUNT|MS_BIND ""): Invalid argument
# !! TODO(pts): why needed after: apt-get install docker? systemctl start docker; also for openssh-server; solution: rm /usr/sbin/policy-rc.d
# !! TODO(pts): The --bind /shared directory.
# !! TODO(pts): timezone -- which packages are needed?
# !! TODO(pts): /etc/default/locale ?
# !! TODO(pts): Add "$HOSTNETIP host" or "$LOCALNETIP host" to /etc/hosts , also copy from/to host /etc/hosts
# !! TODO(pts): Add other type of networking: same-as-host (bind on the same port won't work), private, separate-ip (currently implemented), to-host, to-host-and-containers, host (-n, may include masquerade; only works if the container is also running systemd (because of DHCP client); no communication with other containers).
#

if test -z "$RUNN_RERUN" && ! (test $# = 0 || test "$1" = --help); then
  unset S
  test "$(id -u)" != 0 && S='sudo --'
  exec $S /usr/bin/env -i TZ="$TZ" TERM="$TERM" RUNN_RERUN=1 /bin/sh "$0" "$@"
  exit 1
fi

CMD=
if test "$1" = start || test "$1" = shell || test "$1" = login || test "$1" = poweroff || test "$1" = kill || test "$1" = show; then
  if test $# != 1; then
    CMD="$1"; CONAME="$2"; shift; shift
  fi
elif test "$1" = list; then
  if test $# = 1; then
    CMD="$1"; shift
  fi
elif test $# = 1 && test "${1#-}" = "$1"; then
  CMD=start; CONAME="$1"; shift
fi
if test "$CMD" = start || test "$CMD" = login || test "$CMD" = poweroff || test "$CMD" = show; then
  test $# != 0 && CMD=  # Too many command-line arguments.
fi
if ! test "$CMD"; then
  echo "\
$0: conconj container manager
Usage: $0 [start] <container-name>
       $0 shell <container-name>  # Root shell.
       $0 show <container-name>
       $0 poweroff <container-name>  # Gracefully, don't wait.
       $0 kill <container-name> [<arg> ...]
       $0 login <container-name>
       $0 list  # List active containers." >&2
  exit 1
fi

if test "$CMD" = list; then
  exec machinectl "$CMD" "$@"
  echo "fatal: command not found: machinectl" >&2
  exit 2
fi

case "$CONAME" in
 -* | *[!-._a-zA-Z0-9]* | "") echo "fatal: bad container name: $CONAME"; exit 1 ;;
esac
CODIR="${0%/*}"
cd "$CODIR" || exit 2

if test "$CMD" = start || test "$CMD" = shell; then
  if machinectl show "$CONAME" 2>/dev/null >&2; then  # Early exit.
    if test "$CMD" = start; then
      echo "info: shutdown gracefully: $0 poweroff $CONAME" >&2
      echo "info: force kill: $0 kill $CONAME -s 9" >&2
      echo "fatal: container already running: $CONAME" >&2
      exit 2
    fi
  elif test "$CMD" = shell; then
    CMD=start-shell
    if test $# != 0 && test "${1#/}" = "$1"; then
      # For compatibility with machinectl shell.
      echo "fatal: shell command must start with /: $1" >&2
      exit 1
    fi
  fi
fi
if test "$CMD" = shell && test $# = 0; then  # machinectl systemd 232 doesn't autodetect /bin/bash.
  test -f "$CONAME".container/rootfs/bin/bash && set /bin/bash -l
fi
if test "$CMD" != start && test "$CMD" != start-shell; then
  exec machinectl "$CMD" "$CONAME" "$@"
  echo "fatal: command not found: machinectl" >&2
  exit 2
fi
set x -- "$@"; shift

if ! test -f "busybox.conconj" || ! test -x "busybox.conconj"; then
  echo "fatal: executable not found: $CODIR/busybox.conconj"
  exit 2
fi
if ! test -d "$CONAME.container/rootfs"; then
  echo "fatal: missing rootfs directory in container: $CODIR/$CONAME.container/rootfs"
  exit 2
fi
if ! test -f "$CONAME.container/rootfs/bin/sh"; then
  echo "fatal: missing shell in container: $CODIR/$CONAME.container/rootfs/bin/sh"
  exit 2
fi
export PERL_BADLANG=x  # Unnecessary, because LC_* is unset.
if ! perl -e0 2>/dev/null; then
  echo "fatal: perl doesn't work" >&2
  exit 2
fi
CONIP=
read CONIP <"$CONAME".container/ipaddr 2>/dev/null ||:
HOSTNETIP=; LOCALNETIP=
case "$CONIP" in
 private | shared) ;;
 [1-9]*) HOSTNETIP=. ;;
 local.[1-9]*) LOCALNETIP=. ;;
 "") echo "fatal: missing per-container ipaddr config file: $CODIR/$CONAME.container/ipaddr" >&2; exit 2 ;;
 *) echo "fatal: bad IP address syntax in per-contaier ipaddr config file: $CONAME.container/ipaddr: $CONIP" >&2; exit 2 ;;
esac
if test "$HOSTNETIP" && ! read HOSTNETIP 2>/dev/null <conconj.hostnet; then
  echo "fatal: missing or empty: $CODIR/conconj.hostnet"
  exit 2
fi
if test "$LOCALNETIP" && ! read LOCALNETIP 2>/dev/null <conconj.localnet; then
  echo "fatal: missing or empty: $CODIR/conconj.localnet"
  exit 2
fi

# ---

chown 0.0 "$CONAME".container/rootfs || exit 2

# TODO(pts): Don't do these if "$CONIP" = private etc. (?)
NETGATEWAY="$(ip route | while read A B C D; do
      if test "$A" = default && test "$B" = via; then
        case "$C" in *[!0-9.]*) ;; *) echo "$C"; break ;; esac
      fi
    done)"
NETDEVIP="$HOSTNETIP"
test "$NETDEVIP" || NETDEVIP="$NETGATEWAY"
NETDEV=; NETMASKBITS=; NETMASK=;
if test "$NETDEVIP"; then
  # Example: NETDEVIP=192.168.0.90 NETDEV=wlp2s0
  NETDEV="$(ip -o addr | perl -we 'use integer; use strict;
      die "fatal: bad netdevip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@;
      my $netdevip = unpack("N", pack("C4", $1, $2, $3, $4));
      my $netdev; my $netmaskbits; my $netmask;
      while (<STDIN>) { chomp; my @l = split; if (@l > 3 and $l[2] eq "inet" and $l[1] ne "lo" and $l[3] =~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)/(\d+)\Z(?!\n)@ and $5 != 32 and $5 >= 8 and $5 <= 32) {
        my $ip = unpack("N", pack("C4", $1, $2, $3, $4)); my $mask = unpack("N", pack("N", -1 << (32 - $5))); if (($ip & $mask) == ($netdevip & $mask)) {
          die "fatal: multiple network devices for netdevip: $ARGV[0]\n" if defined($netdev);  # The $5 != 32 check above ensures that cc-hostnet is ignored here.
          $netdev = $l[1]; $netmaskbits = $5; $netmask = $mask; } } }
      die "fatal: missing network device for netdevip: $ARGV[0]\n" if !defined($netdev);
      $netmask = join(".", unpack("C4", pack("N", $netmask)));
      print "NETDEV=\x27$netdev\x27; NETMASKBITS=\x27$netmaskbits\x27; NETMASK=\x27$netmask\x27\n"' -- "$NETDEVIP")"
  test "$NETDEV" || exit 2
  eval "$NETDEV"  # Set NETDEV=...; NETMASKBITS=...; NETMASK=...
  test "$NETDEV" || exit 2
  test "$NETMASKBITS" || exit 2
  test "$NETMASK" || exit 2
fi
HOSTNETDEV="$NETDEV"
if test "$LOCALNETIP"; then
  perl -e 'die "fatal: bad localnetip: $ARGV[0]" if $ARGV[0] !~ m@\A(\d+)[.](\d+)[.](\d+)[.](\d+)(?:/32)?\Z(?!\n)@' -- "$LOCALNETIP" || exit 2
  NETDEV=; NETMASKBITS=24; NETMASK=255.255.255.0; NETGATEWAY=;
  NETNETIP="${LOCALNETIP%.*}.0"; NETBRIP="${LOCALNETIP%.*}.1"; CONIP="${LOCALNETIP%.*}.${CONIP##*.}"
  NETBRIP=
  if test "$NETNETIP" = "$NETBRIP" || test "$NETNETIP" = "$LOCALNETIP" || test "$NETNETIP" = "$CONIP" || test "$NETBRIP" = "$LOCALNETIP" || test "$NETBRIP" = "$CONIP" || test "$LOCALNETIP" = "$CONIP"; then
    echo "fatal: IP addresses must be different: net=$NETNETIP bridge=$NETBRIP host=$LOCALNETIP container=$CONIP" >&2
    exit 2
  fi
fi

BM=
if test -e "$CONAME".container/rootfs/sbin/modprobe; then
  # !! TODO(pts): Disable this if CAP_SYS_MODULE is not used.
  UR=
  read UR </proc/sys/kernel/osrelease  # It's OK to fail.
  if test "$UR" && test -d /lib/modules/"$UR"; then
    # TODO(pts): Disallow whitespace in $UR.
    BM="--bind-ro /lib/modules/$UR"
  fi
fi

if test "$CONIP" = private; then
  LINE=""  # No DNS servers in the container please.
else
  ISSR=
  while read A B C; do
    if test "$A" = nameserver; then
      # 127.0.1.1 (and others) indicates dnsmasq, 127.0.0.53 indicates systemd-resolved.
      case "$B" in 127.0.0.53) ISSR=2; break ;; 127.0.*) ISSR=1; break ;; esac
    fi
  done </etc/resolv.conf
  if test "$ISSR"; then  # Local DNS servers are listed in /etc/resolv.conf.
    if test "$ISSR" = 2; then  # systemd-resolved.
      # systemd-resolve: systemd 237, Ubuntu 18.04
      # resolvectl: systemd 245.4, Ubuntu 20.04
      LINE="$(systemd-resolve --status "$HOSTNETDEV" 2>/dev/null || resolvectl --status "$HOSTNETDEV" 2>/dev/null)"  # Network interface.
      case "$LINE" in
       *DNS\ Servers:\ *) ISSR= ;;
       *) ISSR=1 ;;  # Fall back to NetworkManager.
      esac
    fi
    if test "$ISSR" = 1; then  # NetworkManager (can be dnsmasq, systemd-resolved or manual).
      # https://askubuntu.com/a/1298994
      # This works in Ubuntu >=15.04. For Ubuntu 14.04, see command on the answer link above.
      # Example output of nmcli: 12.34.56.78 | 90.123.45.6
      LINE="$(nmcli -f IP4.DNS -t -m tabular dev show 2>/dev/null |
          perl -ne 'if (m@^\d+(?=[.])[\d. |]+[.]\d+$@) { chomp; for (split(m@ *[|] *@, $_)) { print "nameserver $_\n" } }')"
      test "$LINE" && ISSR=
    fi
    if test "$ISSR"; then
      echo "fatal: local DNS server found ($B), could not figure out real DNS servers" >&2
      exit 2
    fi
  else
    LINE="$(cat /etc/resolv.conf)"
  fi
fi
# Now "$LINE" contains the DNS configuration of the host.
# TODO(pts): Add a config option to keep it unmodified.

# Example: ../run/systemd/resolve/stub-resolv.conf
RCL="$(readlink "$CONAME".container/rootfs/etc/resolv.conf)"
if test "$RCL"; then
  A=; case "$RCL" in ../*) A="${RCL#*/}" ;; esac
  test "$A" && case "$A/" in */../*) A="" ;; esac  # Safety.
  case "$A" in run/systemd/resolve/*) test -d "$CONAME".container/rootfs/run/systemd/resolve || mkdir -p "$CONAME".container/rootfs/run/systemd/resolve || exit 2; RCL= ;; esac
fi


if ! test "$RCL"; then  # Container /etc/resolv.conf is not a symlink or it is a systemd symlink.
  : >>"$CONAME".container/rootfs/etc/resolv.conf.container  # Create it if needed.
  # Copy over host resolve config to container /etc/resolv.conf.
  echo "$LINE" | perl -ni -0777 -we '
      use integer; use strict; our %conf; our %confhad;
      BEGIN {
        $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = "";
        local $/ = "\n";
        while (<STDIN>) {
          s@^\s+@@;
          if (s@(.*?): @@) { $key = $1 } elsif (s@^nameserver\s+@@) { $key = "DNS Servers" }
          chomp; next if !length or m@^#@;
          if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ }
        }
        $conf{LLMNR} = "no";
      }
      my $infile = $_;
      while ($infile =~ m@\G(\n|.+\n?)@gc) {
        $_ = $1;
        $_ .= "\n" if !m@\n@; if (m@^nameserver\s+@ and exists($conf{DNS})) { if (!exists($confhad{DNS})) { for my $dns (split(/ /, $conf{DNS})) { print "nameserver $dns\n" } $confhad{DNS} = 1 } } else { print }
      }
      if (exists($conf{DNS}) and !exists($confhad{DNS})) { for my $dns (split(/ /, $conf{DNS})) { print "nameserver $dns\n" } }
  ' "$CONAME".container/rootfs/etc/resolv.conf.container || exit 2
fi
# Container /etc/resolv.conf may get overwritten by systemd-nspawn at container startup.
cat <"$CONAME".container/rootfs/etc/resolv.conf.container >"$CONAME".container/rootfs/etc/resolv.conf || exit 2

# TODO(pts): Security: don't follow symlinks.
#
# The file "$CONAME".container/rootfs/etc/systemd/resolved.conf is user-editable.
if test -f "$CONAME".container/rootfs/etc/systemd/resolved.conf; then
  # Copy over host resolve config to container /etc/systemd/resolved.conf.
  echo "$LINE" | perl -ni -0777 -we '
      use integer; use strict; our %conf; our %confhad;
      BEGIN {
        $conf{DNS} = ""; $conf{MulticastDNS} = "no"; $conf{DNSSEC} = "no"; $conf{LLMNR} = "no"; my $key = "";
        local $/ = "\n";
        while (<STDIN>) {
          s@^\s+@@;
          if (s@(.*?): @@) { $key = $1 } elsif (s@^nameserver\s+@@) { $key = "DNS Servers" }
          chomp; next if !length or m@^#@;
          if ($key eq "DNS Servers") { $conf{DNS} .= " " if length($conf{DNS}); $conf{DNS} .= $_; } elsif ($key =~ m@^(\S+) setting$@ and exists($conf{$1})) { $conf{$1} = $_ }
        }
        $conf{LLMNR} = "no";
      }
      my $infile = $_;
      while ($infile =~ m@\G(\n|.+\n?)@gc) {
        $_ = $1;
        $_ .= "\n" if !m@\n@; if (m@^#?([^\s#=]+)=@ and exists($conf{$1})) { print "$1=$conf{$1}\n"; $confhad{$1} = 1 } else { print }
      }
      for (sort(keys(%conf))) { print "$_=$conf{$_}\n" if !exists($confhad{$_}) }
  ' "$CONAME".container/rootfs/etc/systemd/resolved.conf || exit 2
fi

# This affects the `shell' command, which starts a login shell.
: >>"$CONAME".container/rootfs/etc/profile || exit 2  # Create if needed.
perl -pi -0777 -we '
    my $cmd = qq(if test -f /etc/resolv.conf.container.start; then umount /etc/resolv.conf 2>/dev/null; rm -f /etc/resolv.conf; cat </etc/resolv.conf.container >/etc/resolv.conf; rm -f /etc/resolv.conf.container.start; :; fi  #conconj\n) .
              qq(if test -f /etc/netup.container; then (. /etc/netup.container); rm -f /etc/netup.container; fi  #conconj\n) .
              qq(/etc/busybox.conconj stty -echoprt -imaxbel </dev/tty >&0  #conconj\n);  # Workaround for \.../ on backspace in `machinectl shell`.
    1 while s@\A(.*) #conconj\n@@;
    substr($_, 0, 0) = $cmd;
    ' "$CONAME".container/rootfs/etc/profile || exit 2

# Undo incorrect setup_resolv_conf() magic in systemd-nspawn, which may
# bind-mount or overwrite /etc/resolv.conf .
# This affects the `start' command (--boot).
# There is no simpler workaround for systemd-nspawn in systemd 237.
# systemd 245.4 has systemd-nspawn --resolv-conf-mode=... to affect this.
if test -d "$CONAME".container/rootfs/etc/systemd/system; then
  # https://www.linode.com/docs/guides/start-service-at-boot/
  echo '
[Unit]
Description=Network interfaces in container
DefaultDependencies=no
Conflicts=shutdown.target
After=
Before=systemd-networkd.service container-resolv-conf.service network.target shutdown.target
#Wants= Requires= Requisite=qqsystemd-resolved.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh /etc/netup.rm.container

[Install]
WantedBy=multi-user.target
' >"$CONAME".container/rootfs/etc/systemd/system/container-network.service || exit 2
  rm -f "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-network.service || exit 2
  # Directory missing before `apt-get install systemd-sysv`.
  if test -d "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants; then
    # Equivalent of in-container: systemctl enable container-network.service
    ln -s /etc/systemd/system/container-network.service "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-network.service || exit 2
  fi
  # !! --network-interface= implies --private-network, so systemd-nspawn doesn't try to mess with /etc/resolv.conf, so this hack is not needed.
  #    undo if not needed (--private-network and --network-interface= don't need it).
  echo '
[Unit]
Description=Set up /etc/resolv.conf in container
DefaultDependencies=no
Conflicts=shutdown.target
After=systemd-resolved.service systemd-networkd.service container-network.service
Before=network.target nss-lookup.target shutdown.target
#Wants= Requires= Requisite=qqsystemd-resolved.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/sh /etc/resolv.conf.container.setup

[Install]
WantedBy=multi-user.target
' >"$CONAME".container/rootfs/etc/systemd/system/container-resolv-conf.service || exit 2
  echo '
if test -f /etc/resolv.conf.container.start; then
  umount /etc/resolv.conf 2>/dev/null
  rm -f /etc/resolv.conf
  # /run/systemd/resolve/resolv.conf contains actual upstream nameservers.
  if test -f /lib/systemd/resolv.conf && (systemd-resolve --status || resolvectl --status) >/dev/null 2>&1; then
    cat </lib/systemd/resolv.conf >/etc/resolv.conf
  else
    cat </etc/resolv.conf.container >/etc/resolv.conf
  fi
  rm -f /etc/resolv.conf.container.start
  :
fi
' >"$CONAME".container/rootfs/etc/resolv.conf.container.setup || exit 2
  #chmod 755 "$CONAME".container/rootfs/etc/resolv.conf.crontainer.setup || exit 2
  rm -f "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-resolv-conf.service || exit 2
  # Directory missing before `apt-get install systemd-sysv`.
  if test -d "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants; then
    # Equivalent of in-container: systemctl enable container-resolv-conf.service
    ln -s /etc/systemd/system/container-resolv-conf.service "$CONAME".container/rootfs/etc/systemd/system/multi-user.target.wants/container-resolv-conf.service || exit 2
  fi
  # systemctl status container-resolv-conf.service
fi


rm -f "$CONAME".container/rootfs/etc/resolv.conf.container.start || exit 2
if test "$CONIP" = shared; then
  test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
  echo "#conconj shared" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
  echo "#conconj shared" >"$CONAME".container/rootfs/etc/netup.container || exit 2
  # TODO(pts): Disable systemd-resolved in the container, so that it doesn't
  # try to bind on UDP 127.0.0.53:53 (which is probably already used by the
  # host).
  # !! disable systemd-resolved.service, to avoid warning: Dec 09 17:18:41 co92 systemd-resolved[30]: Another process is already listening on TCP socket 127.0.0.53:53.
  #    do we need to bind-mount a dummy one to /lib/systemd/system/systemd-resolved.service -- or does /etc take precedence?
elif test "$CONIP" = private; then
  test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
  echo "#conconj private" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
  echo "#conconj private" >"$CONAME".container/rootfs/etc/netup.container || exit 2
  set x --private-network "$@"; shift
else
  CONNETIF=cc."$CONAME"
  if test "$HOSTNETIP"; then
    (ip -o addr show cc-hostnet 2>/dev/null | while read A B C D E; do
      if test "$B" = cc-hostnet && test "$C" = inet && test "$D" != "$HOSTNETIP/32"; then
        echo "fatal: device cc-hostnet already up, with IP address ${D%/*}, should be: $HOSTNETIP" >&2
        exit 2
      fi
    done) || exit 2

    ISMV=
    if ! ip link show cc-hostnet >/dev/null 2>&1; then
      # https://unix.stackexchange.com/q/622914
      # `type macvlan' works on Etherenet only (no wifi), `type ipvlan mode l2' works everywhere.
      # ipvlan vs macvlan: https://sreeninet.wordpress.com/2016/05/29/macvlan-and-ipvlan/
      if test "$ISMV" || ! ip link add name cc-hostnet link "$NETDEV" type ipvlan mode l2 2>/dev/null; then
        # Debian 8 doesn't have ipvlan (not even ipvlan.ko), so we fall back
        # to macvlan. Network won't work (not even from host) over wifi.
        ISMV=1
        if ! ip link add name cc-hostnet link "$NETDEV" type macvlan; then
          # If the error message is `RTNETLINK answers: Device or resource
          # busy', then it may be a macvlan--ipvlan incompatibility. Solve it
          # by stopping all containers, then running `sudo ip link del dev ...'
          # on all conconj.... devices including cc-hostnet.
          echo "fatal: error creating network device: cc-hostnet" >&2
          exit 2
        fi
      fi
      ip addr add "$HOSTNETIP"/32 brd + dev cc-hostnet || exit 2
      ip link set cc-hostnet up || exit 2  # `ip route add' below needs it.
    fi
    ip link del "$CONNETIF" 2>/dev/null ||:
    # ip -n "$CONNETNS" link del "$CONNETIF" 2>/dev/null ||:
    # TODO(pts): If everything is all right (includin type ...lan), don't
    # make any changes, so that currently running shells would continue
    # working.
    if test "$ISMV" || ! ip link add name "$CONNETIF" link "$NETDEV" type ipvlan mode l2 2>/dev/null; then
      # Falling back to macvlan, see above.
      ISMV=1
      if ! ip link add name "$CONNETIF" link "$NETDEV" type macvlan; then
        # If the error message is `RTNETLINK answers: Device or resource
        # busy', then it may be a macvlan--ipvlan incompatibility. Solve it
        # by stopping all containers, then running `sudo ip link del dev ...'
        # on all conconj.... devices including cc-hostnet.
        echo "fatal: error creating network device: $CONNETIF" >&2
        exit 2
      fi
    fi
    test "$(ip route show "$CONIP"/32)" && ip route del "$CONIP"/32
    # This route "$HOSTNETIP"/32 isn't added by default, but we don't need it.
    ip route add "$CONIP"/32 dev cc-hostnet || exit 2
  elif test "$LOCALNETIP"; then
    # Using busybox to avoid the need for `apt-get install bridge-utils'.
    LINE="$(ip link add cb-localnet type bridge 2>&1)"
    case "$?:$LINE" in
     0: | *:\ File\ exists) ;;
     *) echo "$LINE" >&2; echo "fatal: error creating bridge" >&2; exit 2
    esac
    if test "$NETBRIP"; then  # !!! NETBRIP is always empty, remove
      LINE=$(ip -o addr show cb-localnet 2>&1 | while read A B C D E; do
            if test "$C" = inet && test "$D" = "$NETBRIP"/"$NETMASKBITS"; then echo 1
            else echo 2
            fi
          done)
      if test "$LINE" != 1; then
        ip addr flush cb-localnet || exit 2
        # It works (even with forwarding) without a bridge having an IP address.
        ip addr add "$NETBRIP"/"$NETMASKBITS" dev cb-localnet noprefixroute || exit 2
      fi
    fi
    ip link set cb-localnet up || exit 2  # Doesn't add the route because of noprefixroute above.
    if ! ip link show cg-localnet >/dev/null 2>&1 ||
       ! ip link show cc-localnet >/dev/null 2>&1; then
      ip link del dev cg-localnet 2>/dev/null ||:
      ip link del dev cc-localnet 2>/dev/null ||:
      ip link add name cg-localnet type veth peer name cc-localnet || exit 2
      if ! ip link set dev cg-localnet master cb-localnet; then
        echo "fatal: error adding cg-localnet to bridge cc-localnet" >&2
        exit 2
      fi
    fi
    LINE=$(ip -o addr show cc-localnet 2>&1 | while read A B C D E; do
          if test "$C" = inet && test "$D" = "$LOCALNETIP"/"$NETMASKBITS"; then echo 1
          elif test "$C" = inet6; then :
          else echo 2
          fi
        done)
    if test "$LINE" != 1; then
      ip addr flush cc-localnet || exit 2
      ip addr add "$LOCALNETIP"/"$NETMASKBITS" brd + dev cc-localnet || exit 2
    fi
    ip link set cg-localnet up
    ip link set cc-localnet up  # Also adds the route.
    # `ip route del' deletes only one route, so we run it in a loop.
    # Adding the route is not needed, `ip link set cc-localnet up' has done it.
    #    while test "$(ip route show "$NETNETIP"/"$NETMASKBITS")"; do ip route del "$NETNETIP"/"$NETMASKBITS"; done
    #    ip route add "$NETNETIP"/"$NETMASKBITS" dev cc-localnet || exit 2

    ip link del dev cg."$CONAME" 2>/dev/null ||:
    ip link del dev "$CONNETIF" 2>/dev/null ||:
    ip link add name cg."$CONAME" type veth peer name "$CONNETIF" || exit 2
    if ! ip link set dev cg."$CONAME" master cb-localnet; then
      echo "fatal: error adding cg.$CONAME to bridge cc-localnet" >&2
      exit 2
    fi
    ip link set cg."$CONAME" up
    #ip link set "$CONNETIF" up

    #set x --network-interface=cg."$CONAME" "$@"; shift  # Breaks `ping' (even adter ifconfig cg."$CONAME" up), don't do it.
    # !! add NAT
    # !! add DNS only if NAT
    # No need for IP forwarding (echo 1 > /proc/sys/net/ipv4/ip_forward)
    # for the bridge to work.
  fi
  if test -z "$NETMASK"; then
    echo "assert: \$NETMASK not set" >&2
    exit 2
  fi

  # This file is not used directly, it can be used by manually running `ifup -a'
  # after `sudo apt-get install -y ifupdown'.
  test -d "$CONAME".container/rootfs/etc/network || mkdir "$CONAME".container/rootfs/etc/network || exit 2
  NETGATEWAYH=; test "$NETGATEWAY" || NETGATEWAYH="#"
  echo "#conconj
auto lo
iface lo inet loopback

auto $CONNETIF
iface $CONNETIF inet static
  address $CONIP
  netmask $NETMASK
  ${NETGATEWAYH}gateway $NETGATEWAY
" >"$CONAME".container/rootfs/etc/network/interfaces || exit 2;
  # Broadcast is enabled by default, no need for `broadcast +'.
  echo "
/etc/busybox.conconj ifconfig '$CONNETIF' '$CONIP' netmask '$NETMASK' up || exit \$?
${NETGATEWAYH}/etc/busybox.conconj route add default gw '$NETGATEWAY' || exit \$?
" >"$CONAME".container/rootfs/etc/netup.container || exit 2
  set x --network-interface="$CONNETIF" "$@"; shift
  # Undo incorrect setup_resolv_conf() magic in systemd-nspawn, which may
  # bind-mount or overwrite /etc/resolv.conf .  !! undo if not needed (--private-network and --network-interface= don't need it).
  : >>"$CONAME".container/rootfs/etc/resolv.conf.container.start || exit 2  # Create.
fi

# !! mount and umount to busybox
# Maybe docker tries to bind-mount /proc to the container (and that won't work):
#   Dec 10 11:58:37 co18 dockerd[98]: time='2020-12-10T11:58:37Z' level=error msg='failed to disable IPv6 forwarding for container's interface all: open /proc/sys/net/ipv6/conf/all/disable_ipv6: read-only file system'
#   (! test -f /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 || mount --bind /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 /proc/sys/net/ipv6/conf/all/disable_ipv6) &&  # For Docker. Doesn't help.
#   (! test -f /etc/proc/sys/net/ipv6/conf || mount --bind /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 /proc/sys/net/ipv6/conf) &&  # For Docker. Doesn't help.
echo "
    if test -f /proc/sys/net/ipv4/ip_forward && ! (: 2>/dev/null >>/proc/sys/net/ipv4/ip_forward); then
      # Workaround for systemd 229: Read-only filesystem.
      test -d /etc/proc || mkdir /etc/proc
      mount proc /etc/proc -t proc &&
      (! test -f /etc/proc/sys/net/ipv4/ip_forward || mount --bind /etc/proc/sys/net/ipv4/ip_forward /proc/sys/net/ipv4/ip_forward) &&  # For Docker.
      (! test -f /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 || mount --bind /etc/proc/sys/net/ipv6/conf/all/disable_ipv6 /proc/sys/net/ipv6/conf/all/disable_ipv6) &&  # For Docker. Doesn't help.
      umount /etc/proc
    fi
" >>"$CONAME".container/rootfs/etc/netup.container || exit 2
echo "
    if test -f /etc/netup.container; then
      (. /etc/netup.container); XC=\$?
      rm -f /etc/netup.container
      exit \$XC
    fi
" >"$CONAME".container/rootfs/etc/netup.rm.container || exit 2
test -d "$CONAME".container/rootfs/etc/default || mkdir "$CONAME".container/rootfs/etc/default || exit 2
# Disable `ifup -a' call in /lib/systemd/system/networking.service
echo 'CONFIGURE_INTERFACES=no
' >"$CONAME".container/rootfs/etc/default/networking || exit 2;
# Broadcast is enabled by default, no need for `broadcast +'.

if test -f "$CONAME".container/rootfs/etc/pam.d/login &&
   perl -e 'while (<>) { exit 0 if m@ pam_securetty[.]so$@ and !m@^#@ } exit 1' "$CONAME".container/rootfs/etc/pam.d/login ; then
  perl -pi -e 's@^(?=[^#])@#@ if m@ pam_securetty[.]so$@' "$CONAME".container/rootfs/etc/pam.d/login || exit 2
fi

# !! Add setting without Docker.
# Docker needs --capability=CAP_SYS_MODULE,CAP_NET_ADMIN .
# --bind=/sys/fs/cgroup is needed by docker.
# --capability=CAP_SYS_MODULE,CAP_NET_ADMIN is needed by Docker, but not by iptables.
# --capability=all is too much, not needed.
# By using --network-interface=... (but not --network-namespace-path=...),
# this is not needed, docker can set it up for itself:
#   echo 1 | ip netns exec "$CONNETNS" tee /proc/sys/net/ipv4/ip_forward >/dev/null || exit 2

BOOTARG=
test "$CMD" = start-shell || BOOTARG=--boot
set x $BOOTARG --directory="$CONAME".container/rootfs \
    $BM --bind-ro="$(pwd)"/busybox.conconj:/etc/busybox.conconj \
    --capability=CAP_SYS_MODULE,CAP_NET_ADMIN \
    --bind=/proc/sys/net/ipv4:/var/ipv4 \
    --bind=/sys/fs/cgroup --machine="$CONAME" "$@"; shift
# With --private-users=no, container systemd freezes with: ``Failed to allocate manager object, freezing.''.
export SYSTEMD_NSPAWN_USE_CGNS=0  # Needed by Docker.

LINE="$(systemd-nspawn --system-call-filter= --directory=/dev/null 2>&1)"
case "$LINE" in *--system-call-filter=*) ;; *) LINE="" ;; esac
SYSTEMD_NSPAWN=systemd-nspawn
if test "$LINE"; then  # Old systemd-nspawn without --system-call-filter=... .
  if ! test -f patch_nspawn.pl; then
    echo "fatal: script not found: $CODIR/patch_nspawn.pl" >&2
    exit 2
  fi
  LINE="$(type systemd-nspawn 2>&1)"
  case "$LINE" in systemd-nspawn\ is\ /*) LINE="${LINE#* is }" ;; *) LINE="" ;; esac
  if test -z "$LINE"; then
    echo "fatal: command not found: systemd-nspawn" >&2
    exit 2
  fi
  # This can patch systemd-nspawn 232 on Debian 9 on Linux amd64.
  if ! perl patch_nspawn.pl "$LINE" systemd-nspawn.docker; then
    echo "fatal: systemd-nspawn does not support --system-call-filter=... , binary patching didn't work" >&2
    exit 2
  fi
  SYSTEMD_NSPAWN="$CODIR"/systemd-nspawn.docker
  set ./systemd-nspawn.docker "$@"
else
  SYSTEMD_NSPAWN=systemd-nspawn
  set "$SYSTEMD_NSPAWN" --system-call-filter="add_key keyctl" "$@"
fi

if test "$CMD" = start-shell; then
  exec "$@"
  echo "fatal: command not found: $1" >&2
  exit 2
fi

exec 9>"$CONAME".container/console.out.tmp </dev/null
"$@" >&9 2>&9 &  # This generates some shell-specific command-not-found error.
exec 9>&2
while ! read LINE <"$CONAME".container/console.out.tmp; do :; done
E=
case "$LINE" in
 Directory\ tree\ *\ is\ currently\ busy*) E=1 ;;
 Spawning\ *) ;;  # Success (at least so far).
 *:\ not\ found | *:\ command\ not\ found) E=2 ;;
 *) E=0 ;;
esac
if test "$E"; then
  if test "$E" = 1; then  # Already unning.
    echo "info: shutdown gracefully: $0 poweroff $CONAME" >&2
    echo "info: force kill: $0 kill $CONAME -s 9" >&2
    echo "fatal: container already running: $CONAME" >&2
  elif test "$E" = 2; then
    echo "fatal: command not found: $SYSTEMD_NSPAWN" >&2
  else #elif test "$E" = 0; then
    cat "$CONAME".container/console.out.tmp >&2
    rm -f "$CONAME".container/console.out.tmp
  fi
  exit 2
fi
mv "$CONAME".container/console.out.tmp "$CONAME".container/console.out

# Perhaps it's too early (race condition) for poweroff or shell now.
echo "info: started; shutdown gracefully: $0 poweroff $CONAME" >&2
echo "info: force kill: $0 kill $CONAME -s 9" >&2
echo "info: view console: less '$CODIR/$CONAME.container/console.out'" >&2
echo "info: root shell: $0 shell $CONAME" >&2

exit 0
